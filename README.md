[TOC]

创建于2021/9/23

------



# 第1章 理解网络编程和套接字

------



## 1.1 理解网络编程和套接字

### 1.1.1 网络编程和套接字概要

> 网络编程：编写程序使两台联网的计算机相互交换数据。
>
> 套接字（socket）：网络数据传输时用的软件设备。
>
> 网络编程又称套接字编程。

​		电话机可以同时用来拨打或接听，但对套接字而言，拨打和接听是有区别的。我们先讨论用于接听的套接字创建过程。下面利用电话机讲解套接字的创建。

### 1.1.2 构建接电话套接字

- 调用socket函数（安装电话机）进行的对话

  > 问：“接电话需要准备什么？”
  >
  > 答：“当然是电话机啦！”

  有了电话机才能安装电话，接下来我们就准备一部电话机。下列函数创建的就是相当于电话机的套接字：

  ```
  #include<sys/socket.h>
  int socket(int domain, int type, int protocol);
  ```

  > 成功时返回文件描述符，失败时返回-1。

  准备好电话机后要考虑分配电话号码的问题，这样别人才能联系到自己。

  

- 调用bind函数（分配电话号码）时进行的对话

  > 问：“请问您的电话号码是多少？”
  >
  > 答：“我的电话号是123-1234。”

  套接字同样如此。就像给电话机分配电话号码一样（虽然不是真的把电话号码给了电话机），利用一下函数给创建好的套接字分配地址信息（IP地址和端口号）：

  ```
  #include<sys/socket.h>
  int bind(int sockfd, struct sockaddr *myaddr, socklen_t addren);
  ```

  > 成功时返回0，失败时返回-1。

  调用bind函数给套接字分配地址后，就基本完成了接电话的所有准备工作。接下来 需要连接电话线并等待来电。

  

- 调用listen函数（连接电话线）时进行的对话

  > 问：“已架设完电话机后是否只需连接电话线？”
  >
  > 答：”对，只需连接就能接听电话。“

  已连接电话线，电话机就转为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接收连接的状态：

  ```
  #include<sys/socket.h>
  int listen(int sockfd, int backlog);
  ```

  > 成功时返回0，失败时返回-1。

  连接好电话线后，如果有人拨打电话就会响铃，拿起话筒才能接电话。

  

- 调用accept函数（拿起话筒）时进行的对话

  > 问：”电话铃响了，我该怎么办？“
  >
  > 答：”接听啊！“

  拿起话筒意味着接受了对方的连接请求。套接字同样如此，如果有人为了完成数据传输而请求连接，就需要调用一下函数进行受理。

  ```
  #include<sys/socket.h>
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  ```

  > 成功时返回文件描述符，失败时返回-1。

  

  网络编程中接受请求的套接字创建过程可整理如下：

  - 第一步：调用socket函数创建套接字。

  - 第二步：调用bind函数分配IP地址和端口号。

  - 第三步：调用listen函数转为可接受请求状态。

  - 第四步：调用accept函数受理连接请求。

    

### 1.1.3 编写server套接字程序

> 服务器端（server）是能够受理连接请求的程序。下面构建服务器端以验证之前提到的函数调用过程，该服务器端收到连接请求后，向请求者返回”Hello world!“答复。阅读代码时请重点关注套接字和相关函数的调用过程，不必理解全部示例。

​	服务器端代码请参见：[hello_server.c](SK01/hello_server.c)



### 1.1.4 构建打电话套接字

- 下面介绍用于请求连接的客户端套接字，客户端程序只有两个步骤：

  1. 调用socket函数创建套接字

  2. 调用connect函数向服务器端发送连接请求

     

- connect函数：

  ```
  #include<sys/socket.h>
  int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addren);
  ```

  > 成功时返回0，失败时返回-1。

   

### 1.1.5 编写client套接字程序

- 客户端源代码参见：[hello_client.c](SK01/hello_client.c)



### 1.1.6 在Linux平台下运行

1. 对`hello_server.c`示例进行编译的命令：

   ```
   gcc hello_server.c -o hserver
   ./hserver 9190			// 9190是服务器中开启的端口号
   ```

   > 编译`hello_server.c`文件并生成可执行文件`hserver`。

   

2. 对`hello_client`示例进行编译的命令：

   ```
   gcc hello_client.c -o hclient
   ./hclient 127.0.0.1 9190	// 127.0.0.1和9190是分别是服务器的ip地址和端口号
   ```

   此时，client将会接收到由服务器发来的字符串 `Hello World!`



## 1.2 基于Linux的文件操作

​	对Linux而言，socket操作与文件操作没有区别，因而有必要详细了解文件。在Linux世界里，socket也被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件I/O的相关函数。

### 1.2.1 底层文件访问和文件描述符

- 分配给标准输入输出及标准错误的文件描述符

  | 文件描述符 |           对象            |
  | :--------: | :-----------------------: |
  |     0      | 标准输入：Standard Input  |
  |     1      | 标准输出：Standard Output |
  |     2      | 标准错误：Standard Error  |

  文件和套接字一般经过创建过程才会被分配文件描述符。文件描述符有时也被称为文件句柄，但”句柄“主要是Windows中的术语。



### 1.2.2 打开文件

- 首先介绍打开文件来读写数据的函数：

  ```
  #include<sys/types.h>
  #include<sys/stat.h>
  #include<fcnt1.h>
  
  int open(const char * path, int flag);	// 打开文件函数
  ```

  > 成功时返回文件描述符，失败时返回-1。
  >
  > 此函数需传递两个参数：
  >
  > - 第一个参数：path是打开的目标文件名及路径信息。
  > - 第二个参数：flag是文件打开模式（文件特性信息）。

  

- 文件打开模式：

  |  打开模式  | 含义                       |
  | :--------: | -------------------------- |
  | `O_CREAT`  | 必要时创建文件             |
  | `O_TRUNC`  | 删除全部现有数据           |
  | `O_APPEND` | 维持现有数据，保存到其后面 |
  | `O_RDONLY` | 只读打开                   |
  | `O_WRONLY` | 只写打开                   |
  |  `O_RDWR`  | 读写打开                   |



### 1.2.3 关闭文件

- 使用文件后必须关闭，下面介绍关闭文件时调用的函数：

  ```
  #include<unistd.h>
  int close(int fd);
  ```

  > 成功时返回0，失败时返回-1
  >
  > 参数：`fd`，需要关闭的文件或套接字的文件描述符。

  此函数不仅可以关闭文件，还可以关闭套接字。这再次证明了“Linux操作系统不区分文件与套接字”的特点。



### 1.2.4 将数据写入文件

- 接下来介绍的write函数用于向文件输出（传输）数据。Linux中不区分文件与套接字，因此通过套接字向其他计算机传递数据时也会用到该函数。前面示例 `hello_server.c`中也调用它传递字符串 `"Hello World!"`。

  ```
  #include<unistd.h>
  ssize_t write(int fd, const void * buf, size_t nbytes);
  ```

  > 成功时返回写入的字节数，失败时返回-1。
  >
  > 参数1：`fd`，显示数据传输对象的文件描述符。
  >
  > 参数2：`buf`，保存要传输数据的缓冲地址值。
  >
  > 参数3：`nbytes`，要传输数据的字节数。

  此函数定义中，size_t是通过typedef声明的unsigned int类型。对ssize_t来说，size_t前面多加的s代表signed,即ssize_t是通过typedef声明的signed int类型。

  

- 创建新文件并保存数据：

  代码见：[`low_open.c`](SK01/low_open.c)

  编译运行：

  ```
  gcc low_open.c -o lopen
  ./lopen
  ```

  然后屏幕会输出文件描述符，并生成`data.txt`文件，里面有`Let's go!`



### 1.2.5 读取文件中的数据

- 与之前的write函数相对应，read函数用来输入（接收）数据。

  ```
  #include<unistd.h>
  ssize_t read(int fd, void * buf, size_t nbytes);
  ```

  > 成功时返回接收的字节数（但遇到文件结尾则返回0），失败时返回-1。
  >
  > 参数1：`fd`，显示数据接收对象的文件描述符。
  >
  > 参数2：`buf`，要保存接收数据的缓冲地址值。
  >
  > 参数3：`nbytes`要接受数据的最大字节数。

  

- 下面示例通过read()函数读取`data.txt`中保存的数据。

  代码见：[low_read.c](SK01/low_read.c)

  编译运行后输出结果为：

  ```
  file descriptor:3
  file data: Let's go!
  ```

  基于文件描述符的I/O操作相关介绍到此结束。该内容同样适用于套接字。



### 1.2.6 文件描述符与套接字

- 下面源代码文件将同时创建文件和套接字，并用整数型态比较返回的文件描述符值。

  代码参见：[`fd_seri.c`](SK01/fd_seri.c)

  运行结果：

  ```
  file destriptor 1: 3
  file descroptor 2: 4
  file descriptor 3: 5
  ```

  从输出的文件描述符整数值可以看出，描述符从3开始以由小到大的顺序编号，因为0、1、2是分配给标准I/O的描述符。

------



# 第二章 套接字类型与协议设置

------



## 2.1 套接字协议及其数据传输特性

### 2.1.1 创建套接字

```
#include<sys/socket.h>
int socket(int domain, int type, int protocol);
```

> 成功时返回文件描述符，失败时返回-1。
>
> 参数1：`domain`，套接字中使用的协议族（Protocol Family）信息。
>
> 参数2：`type`，套接字数据传输类型信息。
>
> 参数3：`protocol`,计算机间通信时用的协议信息。

### 2.1.2 协议族（Protocol Family）

- 奶油意大利面和番茄酱意大利面均属于意大利面的一种，与此类似，套接字通信中的协议也具有一些分类。通过socket函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类。

  头文件`sys/socket.h`中声明的协议族：

  | 名称        | 协议族                 |
  | ----------- | ---------------------- |
  | `PF_INET`   | `IPv4`互联网协议族     |
  | `PF_INET6`  | `IPv6`互联网协议族     |
  | `PF_LOCAL`  | 本地通信的`UNIX`协议族 |
  | `PF_PACKET` | 底层套接字的协议族     |
  | `PF_IPX`    | `IPX Novell`协议族     |

  套接字中实际采用的最终协议信息是通过socket函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。



### 2.1.3 套接字类型（Type）

- 套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。这种说法可能各位会感到疑惑。已通过第一个参数传递了协议族信息，还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式，换言之，socket函数第一个参数`PF_INET`协议族中也存在好多种数据传输方式。



### 2.1.4 套接字类型1：面向连接的套接字（SOCK_STREAM)

如果socket函数的第二个参数传递`SOCK_STREAM`，将创建面向连接的套接字。

传输方式特征整理如下：

- 传输过程中数据不会消失
- 按序传输数据
- 传输的数据不存在数据边界（Boundary ）
- 套接字连接必须一一对应。

下面这句话说明不存在的数据边界：

> 100个糖果是分批传递的，但接收者凑齐100个后才装袋。
>
> 我的理解：100次发送，1次接收，发送和接受次数不等就是不存在数据边界

| 这种情形适用于之前说过的write和read函数                      |
| ------------------------------------------------------------ |
| 传输数据的计算机通过调用3次write函数传递了100个字节的数据，但是接受数据的计算机仅仅调用1次read函数调用就接受了全部100个字节。 |

收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用read函数。只要不超过数组容量，那么数据填满缓冲后可能通过1次read函数的调用就可以读取全部，也有可能调用多次来完成读取。也就是说，在面向连接的套接字中，read函数和write函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。

| 套接字缓冲已满是否意味着数据丢失                             |
| ------------------------------------------------------------ |
| 首先调用read函数从缓冲读取部分数据，因此缓冲并不总是满的。但如果read函数读取速度比接受的数据的速度慢，则缓冲有可能被填满。此时套接字无法在接受数据，但即使这样也不会发生数据丢失，因为传输套接字将停止传输。也就是说，面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务。因此，面向面接的套接字除特殊情况外不会发生数据丢失。 |

| “套接字连接必须一一对应”怎么理解？                   |
| ---------------------------------------------------- |
| 面向连接的套接字只能与另外一个相同特性的套接字连接。 |

| 面向连接的套接字特性总结：                                   |
| ------------------------------------------------------------ |
| 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字 |



### 2.1.5 套接字类型2：面向消息的套接字（SOCK_DGRAM）

如果向socket函数的第二个参数传递SOCK_DGRAM，则将创建面向消息的套接字。面向消息的套接字可以比喻成告诉移动的摩托车快递。面向消息传输方式的特点如下：

- 强调快速传输而非传输顺序
- 传输的数据可能丢失也可能损毁
- 传输的数据有数据边界
- 限制每次传输的数据大小

快递发往同一目的地的2件包裹无需保证顺序，只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，若要传递大量包裹，则需分批发送。另外，如果用2俩摩托车分别发送2件包裹，则则接收者也需要分2次接受。这种特性就是“传输的数据具有数据边界”。

| 面向消息的套接字特性总结：                           |
| ---------------------------------------------------- |
| 不可靠的、不按序传递的、以数据的高速传输目的的套接字 |

另外，面向消息的套接字不存在连接的概念。



### 2.1.6 协议的最终选择

socket函数的第三个参数决定最终采用的协议。前面已经通过前两个参数传递了协议族信息和套接字数据传输方式，这些信息还不够吗？为什么要传输第三个参数呢？

> 可以应对同一协议族中存在的多个数据传输方式相同的协议，所以数据传输方式相同，但是协议不同，需要用第三个参数指定具体的协议信息。

- `IPv4`协议族中面向连接的套接字：

  > 参数`PF_INTET`指`IPv4`网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条件的协议只有`IPPROTO_TCP`，因此可以调用如下的socket函数创建套接字，这种套接字称为TCP套接字。

  ```
  int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  ```

  

- `IPv4`协议族中面向消息的套接字：

  > `SOCK_DGRAM`指的是面向消息的数据传输方式，满足上述条件的协议只有`IPPROTO_UDP`，可以调用如下的socket函数创建套接字，这种套接字称为`UDP`套接字

  ```
  int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
  ```

  

### 2.1.7 面向连接的套接字：TCP套接字示例

- 代码参见：

  [tcp_server.c](SK01/tcp_server.c)	→	与hello_server.c完全相同

  [tcp_client.c](SK01/tcp_client.c)

- 执行结果：

  ```
  Message from server: Hello World! 
  Function read call count: 13 
  ```

  从运行结果可以看出，服务器端发送了13字节的数据，客户端调用13次read函数进行读取。

------



# 第三章 地址族与数据序列

------

## 3.1 分配给套接字的IP地址与端口号

​		IP地址是Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。

### 3.1.1 网络地址（Internet Address）

为使计算机连接到网络并收发数据，必须向其分配IP地址。IP地址分为两类：

- IPv4（Internet Protocol version 4) 4字节地址族
- IPv6（Internet Protocol version 6) 16字节地址族

IPv4与IPv6的差别主要是表示IP地址所用的字节数，目前通用的地址族为IPv4，IPv6的普及还需要时间。

IPv4标准的4字节IP地址分为网络地址和主机（指计算机）地址，且分为A、B、C、D、E等类型。图3-1展示了IPv4地址族，一般不会使用已被预约了的E类型，故省略。

<img src="image\3-1.png" style="zoom:40%;margin:0px" />

网络地址（网络ID）是为区分网络而设置的一部分IP地址。假设向WWW.SEMI.COM公司传输数据，该公司内部创建了局域网，把所有计算机连接起来。因此，首先应向SEMI.COM网络传输数据，也就是说，并非一开始就浏览所有4字节IP地址，进而找到目标主机；而是仅浏览4字节IP地址的网络地址，先把数据传到SEMI.COM网络。SEMI.COM网络（构成网络的路由器）接收到数据后，浏览传输数据的主机地址（主机ID）并将数据传给目标计算机。

图3-2展示了数据传输过程：

<img src="image\3-2.png" style="zoom:35%;margin:0px" />

某主机向203.211.172.103和203.211.217.202传输数据，其中203.211.172和203.211.217为该网络的网络地址。所以，“向相应网络传输数据”实际上是向构成网络的路由器（Router）或交换机（Switch）传输数据，由接受数据的路由器根据数据中的主机地址向目标主机传递数据。



### 3.1.2 网络地址分类与主机地址边界

只需要通过IP地址的第一个字节即可判断网络地址占用的字节数：

- A类地址的首字节范围：0~127
- B类地址的首字节范围：128~191
- C类地址的首字节范围：192~223

还有如下这种表述方式：

- A类地址的首位以0开始
- B类地址的前2位以10开始
- C类地址的前3位以110开始



### 3.1.3 用于区分套接字的端口号

IP用于区分计算机，只要有IP地址就能向目标主机传输数据，但仅凭这些无法传输给最终的应用程序。

所以计算机一般有NIC（网络接口卡）数据传输设备。通过NIC接收的数据内有端口号，操作系统参考端口号把信息传给相应的应用程序。

<img src="image\3_3_3.jpg" alt="d" style="zoom:60%;margin:0px" />

端口号相关信息：

- 端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将1个端口号分配给不同套接字。
- 端口号由16位构成，可分配的端口号范围是0-65535，此外，0-1023是知名端口号（Well-known PORT），一般分配给特定应用程序。
- 端口号对于同一种套接字不能重复，TCP套接字和UDP套接字不为同一种类型，所以允许重复。例如：TCP套接字使用9190端口，其它TCP套接字就无法使用该端口号，但UDP套接字可以使用。

总之，数据传输目标地址同时包含IP地址和端口号，只有这样，数据才会被传输到最终的目的应用程序（应用程序套接字）。



## 3.2 地址信息的表示

应用程序中使用的IP地址和端口号以结构体的形式给出了定义。

### 3.2.1 表示IPv4地址的结构体

填写地址信息时围绕提问为线索进行：

- 提问1：“采用哪一种地址族？”

  回答1：“基于IPv4的地址族。”

  

- 提问2：“IP地址是多少？”

  回答2：“211.204.214.76。”

  

- 提问3：“端口号是多少？”

  回答3：“2048。”

结构体定义如下形态，就能回答上述提问

```c
struct sockaddr_in
{
	sa_family_t  	sin_family;	//地址族（Address Family）
	unit16_t     	sin_port;	//16位TCP/UDP端口号
	struct in_addr	sin_addr;	//32位IP地址
	char	 	   sin_zero[8]; //不使用。
}
```

> 此结构体将作为地址信息传递给bind函数
>
> 其中内嵌的结构体`in_addr`定义如下：
>
> ```c
> struct in_addr
> {
> 	In_addr_t s_addr;	//32位IPv4地址
> }
> ```
>
> 它用来存放32位IP地址

上述结构体中`uint16_t`、`in_addr_t`等类型可以参考POSIX标准，如下表：

| 数据类型名称 |             数据类型说明             |        声明的头文件         |
| :----------: | :----------------------------------: | :-------------------------: |
|    int8_t    |           signed 8-bit int           |         sys/types.h         |
|   uint8_t    |  unsigned 8-bit int (unsigned char)  |         sys/types.h         |
|   int16_t    |          signed 16-bit int           |         sys/types.h         |
|   uint16_t   | unsigned 16-bit int (unsigned short) |         sys/types.h         |
|   int32_t    |          signed 32-bit int           |         sys/types.h         |
|   uint32_t   | unsigned 32-bit int (unsigned long)  |         sys/types.h         |
| sa_family_t  |       地址族（address family）       |        sys/socket.h         |
|  socklen_t   |        长度（length of struct        |        sys/socket.h         |
|  in_addr_t   |        IP地址，声明为uint32_t        | netinet/in.h（arpa/inet.h） |
|  in_port_t   |        端口号，声明为unit16_t        | netinet/in.h (arpa/inet.h)  |

额外定义这些数据类型，是考虑到扩展性的结果。



### 3.2.2 结构体sockaddr_in的成员分析

结构体成员的含义及包含信息：

- 成员sin_family：地址族

  | 地址族（Address Family) | 含义                             |
  | :---------------------: | :------------------------------- |
  |        `AF_INET`        | IPv4网络协议中使用的地址族       |
  |       `AF_INET6`        | IPv6网络协议中使用的地址族       |
  |       `AF_LOCAL`        | 本地通信中采用的UNIX协议的地址族 |

  > AF_LOCAL说明具有多种地址族

  

- 成员sin_port

  该成员保存16位端口号，它以网络字节序保存。

  

- 成员sin_addr

  该成员保存32位IP地址信息，它以网络字节序保存。为理解好该成员，应同时观察结构体in_addr。但结构体in_addr声明为unit32_t，因此只需当作32为整数型即可。

  

- 成员sin_zero

  无特殊含义。只是为使结构体sockaddr_in的大小与sockaddr结构体保持一致而插入的成员。必须填充为0，否则无法得到想要的结果。后面会介绍sockaddr。（sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节）

从之前的代码就可以看出，sockaddr_in结构体变量地址值将以如下方式传递给bind函数。

```c
struct sockaddr_in serv_addr;
...
if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
	error_handling("bind() error");
...
```

> 此处重要的是第二个参数的传递。bind函数的第二个参数期望得到sockaddr结构体变量地址，包括地址族、端口号、IP地址等。从下列代码也可以看出，直接向sockaddr结构体填充这些信息会带来麻烦。
>
> ```c
> struct sockaddr
> {
> 	sa_family_t	 sin_family;	//地址族（address Family）
> 	char		sa_data[14];    //地址信息
> }
> ```
>
> > 此结构体成员sa_data保存的地址信息中需包含IP地址和端口号，剩余部分应填充0，这也是bind函数要求的。而这对于包含地址信息来讲非常麻烦，继而就有了新的结构体sockaddr_in。若按照之前的讲解填写sockaddr_in结构体，则将生成符合bind函数要求的字节流。最后转换为sockaddr型的结构体变量，再传递给bind函数即可。
>
> 
>
> sockaddr_in中是保存IPv4地址信息的结构体。那为何sockaddr还需要通过sin_family单独指定地址族信息呢？
>
> > 答：结构体并非只为IPv4设计，因此，结构体sockaddr要求在sin_family中指定地址族信息。为了与sockaddr保持一致，sockaddr_in中也有地址族信息。
> >
> > 当然，sockaddr结构体容不下IPv6地址信息，所以出现了struct sockaddr_storage结构体，它可以容得下所有类型的地址族。具体了解可参考文献：[Socket IPV6相关结构体](https://blog.csdn.net/myvest/article/details/100859333)



## 3.3 网络字节序与地址变换

不同的CPU中，4字节整数值1在内存空间保存方式是不同的。

有些CPU这样保存：

|  1   | 00000000 00000000 00000000 00000001 |
| :--: | ----------------------------------- |

有些CPU这样保存：

|  1   | 00000001 00000000 00000000 00000000 |
| :--: | ----------------------------------- |

一种是顺序保存，一种是倒序保存。



### 3.3.1 字节序（Order）与网络字节序

CPU向内存保存数据的方式有2种，这意味着CPU解析数据的方式也分为2种。

- 大端序（Big Endian）：高位字节存放到低位地址。
- 小端序（Little Endian）：高位字节存放到高位地址。

下面通过示例进行说明：

- 大端序CPU保存方式

  <img src="image\3.3.1_1.png" style="zoom:25%;margin:0px" />

> 说明：在0x20号开始的地址中保存4字节int类型数0x12345678
>
> 整数0x12345678中，0x12是高位字节，0x78是低位字节。因此大端序中先保存最高位字节0x12到低位地址0x20。

- 小端序字节保存方式

  <img src="image\3.3.1_2.png" style="zoom:31%;margin:0px" />

> 先保存的是低位字节0x78。

字节序不同的计算机之间数据传递过程中可能出现的问题，如图所示：

<img src="image\3.3.1_3.png" alt="1" style="zoom:40%;margin:0px" />

为解决这个问题，在通过网络传输数据时约定统一方式，这种约定称为：网络字节序（Network Byte Order），就是统一为大端序。即先把数据数组转化成大端序格式再进行网络传输。因此，所有计算机接收数据时应识别该数据是网络字节序格式，小端序系统传输数据时因转化为大端序排列方式。



### 3.3.2 字节序转换（Endian Conversions）

相信大家已经理解了为何要在填充sockaddr_in结构体前将数据转换成网络字节序。接下来介绍转换字节序的函数。

- `unsigned short htons(unsigned short);`
- `unsigned short ntohs(unsigned short);`
- `unsigned long htonl(unsigned long);`
- `unsigned long ntohl(unsigned long);`

通过函数名应该能掌握其功能，只需拆分htons，了解其中细节：

- htons中的h代表主机（host）字节序
- htons中的n代表网络（network）字节序

另外，s指的是short，l指的是long（Linux中的long类型占用4个字节，这很关键）。因此，htons是h、to、n、s的组合，可以解释为：“把short型数据从主机字节序转化为网络字节序”。

再举一个例子，ntohs可以解释为：“把short型数据从网络字节序转化为主机字节序”。

通常，以s作为后缀的函数中，s代表2个字节short，因此用于端口转换（16位）；以l作为后缀的函数中，l代表4个字节long，因此用于IP地址转换（32位）。

下面通过代码示例说明以上函数的调用过程。

代码参见：[endian_conv.c](SK03/endian_conv.c)

运行结果：

```
Host ordered port: 0x1234 
Network order port: 0x3412 
Host order address: 0x12345678 
Network order address 0x78563412 
```

> 这是在小端序CPU中运行的结果。如果在大端序CPU中运行，则变量值不会改变。
>
> Intel和AMD的CPU都是小端序为标准。



## 3.4 网络地址的初始化与分配

### 3.4.1 将字符串信息转换为网络字节序的整数型

sockaddr_in中需要的是32位整数型，但是我们只熟悉点分十进制表示法，那么该如何把类似于201.211.214.36转换为4字节的整数类型数据呢？幸运的是，有一个函数可以将字符串形式的IP地址转换成32位整数型数据。此函数在转换类型的同时进行网络字节序转换。

```c
#include<arpa/inet.h>
in_addr_t inet_addr(const char * string);
```

> 成功时返回32位大端序整数型值，失败时返回INADDR_NONE。
>
> 如果向该函数传递类似“211.214.107.99“的点分十进制格式的字符串，它会将其转换为32位整数型数据并返回。当然，该整数型值满足网络字节序。另外，该函数的返还类型in_addr_t在内部声明为32位整数型。

下列代码示例表示该函数的调用过程：

- 代码参见：[inet_addr.c](SK03/inet_addr.c)

- 运行结果：

  ```
  Network ordered integer addr: 0x4030201 
  Error occureded 
  ```

> 从运行结果可以看出，inet_addr函数不仅可以把IP地址转成32位整数型，而且可以检测无效的IP地址。另外，从输出结果可以验证确实转换为网络字节序。



inet_aton函数与inet_addr函数在功能上完全相同，也将字符串形式IP地址转换为32位网络字节序整数并返回。不同的是该函数利用了in_addr结构体，且使用频率更高。

```c
#include<arpa/inet.h>
int inet_aton(const char * string, struct in_addr * addr);
```

> 成功时返回1（true），失败时返回0（false）。
>
> 参数1：string，含有需转换的IP地址信息的字符串地址值。
>
> 参数2：addr，将保存转换结果的in_addr结构体变量的地址值。

调用inet_addr函数，返回转换后的IP地址信息还需保存到sockaddr_in结构体中声明的in_addr结构体变量。

而inet_aton函数则不需此过程。因为该函数会自动把结果存入该结构体变量。

通过代码示例，了解inet_aton函数的调用过程：

代码参见：[inet_aton.c](SK03/inet_aton.c)

运行结果：

```
Network order integer addr: 0x4f7ce87f 
```

可以看出，已经成功的把转换后的地址放进了addr_inet.sin_addr.s_addr中



最后再介绍一个与inet_aton函数正好相反的函数inet_ntoa，此函数把网络字节序整数型IP地址转换成我们熟悉的字符串形式。

```c
#include<apra/inet.h>
char * inet_ntoa(sturct in_addr addr);
```

> 成功时返回转换的字符串地址值，失败时返回-1。
>
> 调用时需要小心，返回值类型为char指针。返回的字符串地址意味着字符串已保存到内存空间，但该函数未向程序员要求分配内存，而是在内部申请了内存并保存了字符串。也就是说，调用完该函数后，应立即将字符串信息复制到其他内存空间。因为，若再次调用inet_ntoa函数，则有可能覆盖之前保存的字符串信息。总之，再次调用inet_ntoa函数前返回的字符串地址值是有效的。若需要长期保存，则应将字符串复制到其他内存空间。

代码示例参见：[inet_ntoa.c](SK03/inet_ntoa.c)

运行结果：

```
Dotted-Decimal notation1: 1.2.3.4 
Dotted-Decimal notation2: 1.1.1.1 
Dotted-Decimal notation3: 1.2.3.4 
```



### 3.4.2 网络地址初始化

套接字创建过程中常见的网络地址初始化方法：

```c
struct sockaddr_in addr;
char * serv_ip = "211,217.168.13";	//声明IP地址的字符串
char * serv_port = "9190";			//声明端口号字符串
memset(&addr, 0, sizeof(addr));		//结构体变量addr的所有成员初始化为0
addr.sin_family = AF_INET;			//指定地址族
addr.sin_addr.s_addr = inet_addr(serv_ip);	//基于字符串的IP地址初始化
addr.sin_port = htons(atoi(serv_port)); 	//基于字符串的端口号初始化
```

上述代码中，memset函数将每个字节初始化为同一值：

- 第一个参数为结构体变量addr的地址值，即初始化对象为addr
- 第二个参数为0，因此初始化值为0
- 第三个参数传入addr的长度

因此addr的所有字节均初始化为0。这么做是为了将sockaddr_in结构体的成员sin_zero初始化为0。

最后一行代码调用的atoi函数把字符串类型的值转换成整数型。

总之，上述代码利用字符串格式的IP地址和端口号初始化了sockaddr_in结构体变量。

> 另外，代码中对IP地址和端口号进行了硬编码，这并非良策，因为运行环境改变就得更改代码。因此，我们运行时传入IP地址和端口号会更好。



### 3.4.3 客户端地址信息初始化

上述网络地址信息初始化过程主要针对服务器端而非客户端。给套接字分配IP地址和端口号主要是为下面这件事做准备：

> “请把进入IP 211.217.168.13、9190端口的数据传给我！”

反观客户端中连接请求如下：

> “请连接到IP 211.217.168.13、9190端口！”

请求方法不同意味着调用的函数也不同：

- 服务器端的准备工作通过bind函数完成
- 客户端的准备工作通过connect函数完成

因此函数调用前需准备的地址值类型也不同：

- 服务器端声明sockaddr_in结构体变量，将其初始化为赋予服务器端IP和套接字的端口号，然后调用bind函数
- 客户端声明sockaddr_in结构体,并初始化为要与之连接的服务器端套接字的IP和端口号，然后调用connect函数。



### 3.4.4 INADDR_ANY

每次创建服务器端套接字都要输入IP地址会有些繁琐，此时可如下初始化地址信息：

```c
struct sockaddr_in addr;
char * serv_port = "9190";
memset(&addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
add.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port = htons(atoi(serv_port));
```

> 采用`INADDR_ANY`参数，则可自动获取运行服务器端的计算机IP地址，不必亲自输入。

| 创建服务器端套接字时需要IP地址的原因                         |
| ------------------------------------------------------------ |
| 初始化服务器端套接字时应分配所属计算机的IP地址，因为初始化时使用的IP地址非常明确，那为何还要进行IP初始化呢？同一计算机中可以分配多个IP地址，实际IP地址的个数与计算机中安装的NIC的数量相等。即使是服务器端套接字，也需要决定应接收哪个IP地址传来的（哪个NIC传来的）数据。因此，服务器端套接字初始化过程中要求IP地址信息。另外，若只有一个NIC，则直接使用INADDR_ANY。 |



### 3.4.5向套接字分配网络地址

前面了解了sockaddr_in结构体的初始化方法，接下来就把初始化的地址信息分配给套接字。bind函数负责这项操作。

```c
#include<sys/socket.h>
int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrlen);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：`sockfd`，要分配地址信息（IP地址和端口号）的套接字文件描述符
>
> 参数2：`myaddr`，存有地址信息的结构体变量地址值。
>
> 参数3：`addrlen`，第二个结构体变量的长度。

如果此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。

下面给出服务器端常见套接字初始化过程。

```c
int serv_sock;
struct sockaddr_in serv_addr;
char * srev_port = "9190";

/* 创建服务器端套接字（监听套接字）*/
serv_sock = socket(PF_INET, SOCK_STREAM, 0);

/* 地址信息初始化 */
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(atoi(serv_port));

/* 分配地址信息 */
bind(serv_sock, (struct sockaddr * )&serv_addr, sizeof(serv_addr));
```



### 3.6 习题

1. IP地址组IPv4和IPv6有何区别？在何种背景下诞生了IPv6？

   >答：IPv4和IPv6的区别在于字节大小，IPv4为32位，IPv6为64位；
   >
   >为应对IPv4地址耗尽的背景下诞生了IPv6。

2. 通过IPv4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程。

   > 答：当要访问一个公司局域网中的计算机，首先向局域网中的路由器进行访问、传输数据，所以先访问的是局域网的网络ID，当数据传输到该公司局域网中，路由器会根据数据包中的主机ID分发到对应的计算机。

3. 套接字地址分为IP地址和端口号。为什么需要IP地址和端口号？或者说，通过IP可以区分哪些对象？通过端口号可以区分哪些对象？

   > 答：IP地址可以与具体位置的计算机进行数据传输，但还不能够仅仅通过IP地址就能进行数据传输，还需要端口号，操作系统可以根据端口号将数据传输给指定的应用程序，端口号用来区分操作系统中哪一个应用程序进行数据交换。

4. 请说明IP地址的分类方法，并据此说出下面这些IP地址的分类。

   > 答：IP地址根据规模可以分成A类、B类、C类、D类。
   >
   > 第一种分类方法按首字节范围：
   >
   > A类地址的首字节范围为：0~127；B类地址的首字节范围为：127~191；C类地址的首字节范围为：192~223。
   >
   > 第二种分类方法:首位为0为A类地址；前两位为10为B类地址；前三位为110为C类地址；D类地址为多播地址
   >
   > - 214.121.212.102 （C类地址）110
   > - 120.101.122.89 （A类地址）0
   > - 129.78.102.211 （B类地址）10

5. 计算机通过路由器和交换机连接到互联网。请说出路由器和交换机的作用。

   > 答：路由器遵循IP协议，路由器可以查找数据包传输的下一个IP地址。交换机遵循MAC协议，根据路由器查询返回的MAC地址，进行数据传输。

6. 什么是知名端口号？其范围是多少？知名端口中具有代表性的HTTP和FTP端口号各是多少？

   > 答：分配给内部的端口号为知名端口号，其范围为0~1023。HTTP端口号为80端口，FTP端口号为22端口。

7. 向套接字分配地址的bind函数原型如下：

   ```c
   int bind(int sockfd, struct sockaddr * myaddr, socklen_t addren);
   ```

   而调用时则用

   ```c
   bind(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
   ```

   此处serv_addr为sockaddr_in结构体变量。与函数原型不同，传入的时sockaddr_in结构体变量，请说明原因。

   > 答：因为对于详细的地址信息使用sockaddr类型传递特别麻烦，进而有了sockaddr_in类型，通过转换成sockaddr类型，生成满足bind函数需要的参数。

8. 请解释大端序、小端序、网络字节序，并说明为何需要网络字节序。

   > 答：大端序就是高位字节存放到低位地址，小端序就是高位字节存放到高位地址，网络字节序就是网络传输中统一采用的大端序。因为不同CPU可能存在不同的字节存放顺序，为确保网络中传输正确的字节序，于是约定统一转换成网络字节序后再进行网络传输。
   >
   
9. 大端序计算机希望把4字节整数型数据12传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。

   > 答：大端序计算机传输到网络中无需做出改变，当数据传递到小端序计算机时，0x12解析成0x21。

10. 怎么表示回送地址？其含义是什么？如果向会送地址传输数据将发生什么情况？

    > 答：127.0.0.1表示回送地址，指的是计算机自身的IP地址，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。

------





# 第四章 基于TCP的服务器端/客户端（1）

------

我们已经学习了创建套接字和向套接字分配地址，接下来正式讨论通过套接字收发数据。

## 4.1 理解TCP和UDP

根据数据传输方式不同，基于网络协议的套接字一般为TCP和UDP套接字。因为TCP时面向连接的，因此又称基于流（stream）的套接字。

TCP是Transmission Control Protocol(传输控制协议)的简写，意为“对数据传输过程的控制”。

### 4.1.1 TCP/IP协议栈

TCP所属的TCP/IP协议栈：

<img src="image\4.4.1.png" alt="f" style="zoom:55%;margin:0px" />

TCP/IP协议栈分为4层，可以理解为数据收发分成4个层次化过程。下面自下而上依次介绍。



### 4.1.2 链路层

链路层是物理链接领域标准化的结果，专门定义LAN、WAN、MAN等网络标准，链路层就负责这些标准。若两台主机通过网络进行数据交换,就需要物理连接。



### 4.1.3 IP层

IP层解决向目标传输数据需要经过哪条路径这一问题。IP层的协议就是IP协议。

IP本身是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径。IP协议无法应对数据丢失、错误。



### 4.1.4 TCP/UDP层

IP层解决数据传输中的路径选择问题，只需按照此路径传输数据即可。TCP和UDP层以IP提供的路径信息为基础完成实际的数据传输，故该层又称传输层（Transport）。UDP比TCP简单，现只解释TCP。TCP可以保证可靠的数据传输，但它发送数据时以IP层为基础（这也是协议栈结构层次化的原因）。那该如何理解二者关系呢？

IP层只关注1个数据包（数据传输的基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则有可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中有可能只收到A和C，甚至收到的C可能已损毁。反之，若添加TCP协议则按照如下对话进行数据交换。

> 主机A：“正确收到第二个数据包！”
>
> 主机B：“嗯，知道了。”
>
> 主机A：“正确收到第三个数据包!”
>
> 主机B：”可我已发送第四个数据包了啊！哦，您没收到第四个数据包吧？我给您重传！”

这就是TCP的作用。如果数据交换过程中可以确认对方已收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的。

图4-5简单描述了TCP的功能。

<img src="image\4.1.4.png" alt="1" style="zoom:55%;margin:0px" />

总之，TCP和UDP存在于IP层之上，决定主机之间的数据传输方式，TCP协议确认后向不可靠的IP协议赋予可靠性。



### 4.1.5 应用层

上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部。 向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。（可以联想实时直播和短视频所需要的数据传输规则来理解应用层协议） 



## 4.2 实现基于TCP的服务器端/客户端

### 4.2.1 TCP服务器端的默认函数调用顺序

绝大部分TCP服务器端都按照该顺序调用:

<img src="image\4.2.1.png" style="zoom:80%;margin:0px" />

调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。这2个阶段之前已讨论过，下面讲解之后的几个过程。

### 4.2.2进入等待连接请求状态

我们已调用bind函数给套接字分配了地址，接下来就要通过调用listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态。换言之，这时客户端才能调用connect函数（若提前调用将发生错误）。

```c
#include<sys/socket.h>
int listen(int sock, int backlog);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：`sock`，希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数称为服务器端套接字（监听套接字）。
>
> 参数2：`backlog`，连接请求等待队列（Queue）的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列。
>
> 向解释一下”等待连接请求状态“的含义和“连接请求等待队列。“服务器端处于等待连接请求状态”是指，客户端请求连接时，受理连接前一直使请求处于等待状态。图4-7给出了这个过程。
>
> <img src="image\4.2.2.png" alt="1" style="zoom:50%;margin:0px" />
>
> 由上图可知作为listen函数的第一个参数传递的文件描述符套接字的用途。
>
> 客户端连接请求本身也是从网络中接收到的一种数据，而要想接收就需要套接字。此任务就由服务器端套接字来完成。服务器端套接字是接受连接请求的一名门卫或一扇门。
>
> 客户端如果向服务器端询问：“请问我是否可以发起连接？”服务器端套接字就会回答：“您好！当然可以，但系统正忙，请到等候室排号等待，准备好后会立即受理您的连接。”同时将连接请求请到等候室。调用listen函数即可生成这种门卫（服务器端套接字），listen函数的第二个参数决定了等候室的大小。等候室称为连接请求等待队列，准备好服务器端套接字和请求等待队列后，这种可接收连接请求的状态称为等待连接请求状态。



### 4.2.3 受理客户端连接请求

调用listen函数后，若有新的连接请求，按序受理。受理请求意味着进入可接受数据的状态。也许各位已经猜到进入这种状态所需部件——套接字！大家可能认为使用服务器端套接字，当服务器端套接字是做门卫的。如果在与客户端的数据交换中使用门卫，那谁来守门呢？因此需要另外一个套接字，但没必要亲自创建。下面这个函数自动创建套接字，并连接到发起请求的客户端。

```c
#include<sys/socket.h>
int accept(int sock, struct sockaddr * adr, socklen_t * addrlen);
```

> 成功时返回创建的套接字文件描述符，失败时返回-1。
>
> 参数1：`sock`，服务器套接字的文件描述符
>
> 参数2：`addr`，保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息。
>
> 参数3：`addrlen`，第二个参数`addr`结构体的长度，但是是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度。

accept函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接。图4-8展示了accept函数调用过程。

<img src="image\4.2.3.png" alt="1" style="zoom:50%;margin:0px" />



### 4.2.4回顾Hello world服务器端

代码回顾：[hello_server.c](SK04/hello_server.c)

服务器端的基本实现过程如下：

1. 服务器端实现过程中首先要创建套接字	

   ```
   serv_sock = socket(PF_INET, SOCK_STREAM, 0);
   ```

   > 但此时套接字尚非真正的服务器端套接字。

   

2. 为了完成套接字地址分配，初始化结构体变量并调用bind函数

   ```c
   memset(&serv_addr, 0, sizeof(serv_addr));
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
   serv_addr.sin_port = htons(atoi(argv[1]));
   
   if(bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
   	error_handling("bind() error");
   ```

   

3. 调用listen函数进入等待连接请求状态。

   ```c
   if(listen(serv_sock, 5) == -1)
   	error_handling("listen() error");
   ```

   > 此时的套接字才是真正的服务器端套接字

   

4. 调用accept函数从队头取1个连接请求与客户端建立连接，并返回创建的套接字文件描述符。

   ```c
   clnt_addr_size = sizeof(clnt_addr);
   clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
   if(clnt_sock==-1)
   	error_handling("accept() error");
   ```

   

5. 调用write函数向客户端传输数据

   ```c
   write(clnt_sock, message, sizeof(message));
   ```

   

6. 调用close函数关闭连接

   ```c
   close(clnt_sock);
   close(serv_sock);
   ```



### 4.2.5 TCP客户端的默认函数调用顺序

接下来讲解客户端的实现顺序。创建套接字和请求连接就是客户端的全部内容，所以要比服务器端简单多。

<img src="image\4.2.5.png" alt="1" style="zoom:45%;margin:0px" />

与服务器端相比，区别就在于“请求连接”，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。那如何发起连接请求呢？通过调用如下函数完成。

```c
#include<sys/socket.h>
int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：sock，客户端套接字文件描述符
>
> 参数2：servaddr，保存目标服务器端地址信息的变量地址值。
>
> 参数3：addrlen，已传递给第二个结构体参数servaddr的地址变量长度。

客户端调用connect函数后，发生以下情况之一才会返回（成功函数调用）。

- 服务器端接受连接请求。
- 发生断网等异常情况而中断连接请求。

需要注意，所谓的“接收连接“并不意味着服务器端调用accept函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。

| 客户端套接字地址信息在哪里？                                 |
| ------------------------------------------------------------ |
| 实现服务器端必经过程之一说就是给套接字分配IP和端口号。当客户端实现过程中并未出现套接字地址分配，而是创建套接字后立即调用connect函数。难道客户端套接字无需分配IP和端口？当然不是！网络数据交换必须分配IP和端口。既然如此，那客户端套接字何时、何地、如何分配地址呢？ |

- 何时？

  调用connect函数时。

- 何地?

  操作系统，更准确地说是在内核中。

- 如何？

  IP用计算机（主机）的IP，端口则随机。

客户端的IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。



### 4.2.6 回顾Hello world客户端

代码回顾：[hello_client.c](SK01/hello_client.c)

重新理解这个程序：

1. 创建准备连接服务器的套接字，此时创建的是TCP套接字
2. 结构体变量serv_addr中初始化IP和端口信息。初始化值目标服务器端套接字的IP和端口信息。
3. 调用convert函数向服务器端发起连接请求
4. 完成连接后，接收服务端传输的数据
5. 接受数据后调用close函数关闭套接字，结束与服务器端的连接



### 4.2.7 基于TCP的服务器端/客户端函数调用关系

<img src="image\4.2.7.png" style="zoom:60%;margin:0px" />

总体流程整理如下：服务器端创建套接字后连续调用bind、listen函数进入等待状态，客户端通过调用connect函数发起连接请求。需要注意的是，客户端只能等到服务器端调用listen函数后才能调用connect函数。同时要清楚，客户端调用connect函数前，服务器端有可能率先调用accept函数。当然，此时服务器端在调用accept函数时进入阻塞（blocking）状态，直到客户端调用connect函数为止。



## 4.3 实现迭代服务器端

之前讨论的Hello world服务器端处理完一个客户端连接请求即退出，连接请求等待队列实际没有太大意义。但这并非我们想象的服务器端。设置好等待队列的大小后，应向所有客户端提供服务。如果想继续受理后续的客户端连接请求，最简单的办法就是插入循环语句反复调用accept函数，如图4-11所示。

<img src="image\4.2.8.png" style="zoom:60%;margin:0px" />

从上图可以看出，调用accept函数后，紧接着调用I/O相关的read、write函数，然后调用close函数。close并非针对服务器端套接字，而是针对accept函数调用时创建的套接字。

调用close函数就意味着结束了针对某一客户端的服务。此时如果还想服务于其他客户端，就要重新调用accept函数。

可能就有人吐槽了：

> “这算什么啊？又不是银行窗口，好歹也算是一个服务器端，难道同一时刻只能服务于一个客户端吗？

是的！同一时刻确实只能服务于一个客户端，将来学完进程和线程后，就可以编写同时服务多个客户端的服务器端了。目前只能做到这一步。



### 4.3.1 迭代回声服务器端/客户端

前面讲的就是迭代服务器端。即使服务器端以迭代方式运转，客户端代码亦无太大区别。接下来创建迭代回声服务器端及其配套的回声客户端。首先整理一下程序的基本运行方式：

- 服务器端在同一时刻只与一个客户端相连，并提供回声服务。
- 服务器端依次向5个客户端提供服务并退出。
- 客户端接收用户输入的字符串并发送到服务器端。
- 服务器端将接受的字符串数据传回客户端，即“回声”。
- 服务器端与客户端之间的字符串回声一直执行到客户端输入Q为止。

满足以上要求的回声服务器端程序：

> 代码参见：[echo_server.c](SK04/echo_server.c)
>
> 该服务器命名为回声服务器，是因为该服务器的功能是原路返回客户端传输的数据。
>
> 运行结果：
>
> ```
> Connected client 1 
> Connected client 2 
> Connected client 3 
> Connected client 4 
> Connected client 5 
> ```
>
> 向5个客户端提供服务后会关闭服务器端套接字并终止程序。



回声客户端程序：

> 代码参见：[echo_client.c](SK04/echo_client.c)
>
> 运行结果：
>
> ```
> Connected........
> Input message(Q to quit):Good evening
> Message from server: Good evening
> Input message(Q to quit):Hi
> Message from server: Hi
> Input message(Q to quit):Q
> ```
>
> 通过结果可以看出，客户端发出的内容就像回声一样从服务器端传回。



### 4.3.2回声客户端存在的问题

下列是echo_client.c中的代码：

```c
write(sock, message, strlen(message));
str_len = read(sock, message, BUF_SIZE - 1);
message[str_len] = 0;
printf("Message from server: %s", message);
```

以上代码有个错误假设：

> “每次调用read、write函数时都会以字符串为单位执行实际的I/O操作。”

每次调用wirte函数都只会传递一个字符串，上述客户端是基于TCP的，TCP不存在数据边界，因此，多次调用write函数传递的字符串有可能一次性传递到服务器端。这时存在问题：客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需要考虑服务器端的如下情况：

> “字符串太长，需要分2个数据包发送！”

服务器端希望通过调用1次write函数传输数据，但如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端有可能在尚未收到全部数据包时就调用read函数。

所有这些问题都源自TCP的数据传输特性。解决方法请见第5章。

你可能会问：

> “但上述示例不是正常运转了吗？“
>
> 答：这是因为收发的数据小，而且运行环境为同一台计算机或相邻的两台计算机，所以没发生错误，可实际上仍存在发生错误的可能。





## 4.5 习题

1. 请说明TCP/IP的4层协议栈，并说明TCP和UDP套接字经过的层级结构差异。

   > 答：TCP/IP协议栈自上而下分别是应用层、TCP/UDP协议所在的传输层、IP层、链路层。差异是一个经过TCP层，一个经过UDP层。

2. 请说出TCP/IP协议栈中链路层和IP层的作用，并给出两者关系。

   > 答：链路层是物理链接领域标准化的结果，为网络传输提供物理连接。IP层负责选择传输路径。IP层构建于链路层之上，在链路层提供的物理链接基础上选择正确可行的物理路径。

3. 为何需要把TCP/IP协议栈分成4层（或7层）？结合开放式系统回答。

   > 答：APRANET的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。分层的好处：①隔层之间是独立的；②灵活性好；③结构上可以分隔开；④易于实现和维护；⑤能促进标准化工作。

4. 客户端调用connect函数向服务器端发送连接请求。服务器端调用哪个函数后，客户端可以调用connect函数？

   > 答：首先服务器端要调用listen函数后，客户端才可以调用connect函数。

5. 什么时候创建连接请求等待队列？它有何作用？与accept有什么关系？

   > 答：当服务器端通过bind函数分配完IP地址和端口号这些网络地址信息时，就要进入准备状态，随时等待客户端的连接，这时就需要调用listen函数，它将创建连接请求等待队列，当服务器套接字忙于受理其他客户端的请求时，后面来的客户端请求可以进入连接请求等待队列中。listen是负责将客户端请求请到连接请求等待队列中，accept则是负责按序受理处于等待队列中待处理的客户端连接请求。

6. 客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，那何时、如何向套接字分配IP地址和端口号？

   > 答：客户端中的网络地址信息在调用connect函数时进行分配。

7. 把第1章的hello_server.c改成迭代器服务器端，并利用客户端测试更改是否准确。

   > 答：迭代器服务器代码：[hello_ite_server.c](SK04/hello_ite_server.c)
   >
   > 运行结果：
   >
   > ```
   > root@iZwz9abtr8fgz78nfnbgjiZ:~/SK04# gcc hello_ite_server.c -o iserver
   > root@iZwz9abtr8fgz78nfnbgjiZ:~/SK04# ./iserver 5009                   
   > Connected client 1 
   > Connected client 2 
   > Connected client 3 
   > Connected client 4 
   > Connected client 5 
   > ```

------





# 第五章 基于TCP的服务器端/客户端（2）

------

第四章通过回声服务示例讲解了TCP服务器端/客户端的实现方法。本章将详细讲解TCP中必要的理论知识，还将给出第四章客户端问题的解决方案。

## 5.1 回声客户端的完美实现

### 5.1.1 回声服务器端没有问题，只有回声客户端有问题？

问题不在服务器端，而在客户端。因为I/O中使用了相同的函数。

- 先回顾回声服务器端的I/O相关代码，参见[echo_server.c](SK04/echo_server.c)

  ```c
  while((str_len = read(clnt_sock, message, BUF_SIZE)) != 0)				
      write(clnt_sock, message, str_len);
  ```

- 接着回顾回声客户端代码，参见[echo_client.c](SK04/echo_client.c)

  ```c
  write(sock, message, strlen(message));
  str_len = read(sock, message, BUF_SIZE - 1);
  ```

二者都在循环调用read或write函数。实际上之前的回声客户端将100%接受自己传输的数据，只不过接收数据时的单位有些问题。扩展客户端代码回顾范围，下面是echo_client.c中要扩展回顾的代码：

```c
while(1)
{
	fputs("Input message(Q to quit): ", stdout);
    fgets(message, BUF_SIZE, stdin);
    ...
    write(sock, message, strlen(message));
    str_len = read(sock, message, BUF_SIZE - 1)
    message[str_len] = 0;
    printf("Message from server: %s", message);
}
```

大家现在理解了吧？回声客户端传输的是字符串，而且是通过调用write函数一次性发送的。之后还调用一次read函数，期待着接收自己传输的字符串。这就是问题所在。



### 5.1.2 回声客户端问题解决办法

办法：因为可以提前确定接受数据的大小。若之前传输了20字节长的字符串，则在接收时循环调用read函数读取20个字节即可。既然有了解决办法，接下来给出其代码：

代码参见：[echo_client2.c](SK05/echo_client2.c)



### 5.1.3 如果问题不在于回声客户端：定义应用层协议

回声客户端可以提前知道接收的数据长度，但我们应该意识到，更多情况下这不太可能。既然如此，若无法预知接收数据长度时应如何收发数据？此时需要的就是应用层协议的定义。之前的回声服务器端/客户端中定义了如下协议。

> “收到Q就立即终止连接。”

同样，收发数据过程中也需要定好规则（协议）以表示数据的边界，或提前告知收发数据的大小。服务器端/客户端实现过程中逐步定义的这些规则集合就是应用层协议。可以看出，应用层协议并不是高深莫测的存在，只不过是为特定程序的实现而制定的规则。

下面编写程序以体验应用层协议的定义过程。该程序中，服务器端从客户端获得多个数字和运算符信息。服务器端收到数字后对其进行加减乘运算，然后把结果传回客户端。例如，向服务器端传递3、5、9的同时请求加法运算，则客户端收到3+5+9的运算结果。

程序设计了如下应用层协议：

- 客户端连接到服务器端后以1字节整数形式传递待算数字的个数
- 客户端向服务器端传递的每个整数型数据占用4字节。
- 传递整数型数据后接着传递运算符。运算符信息占用1字节。
- 选择字符+、-、*之一传递。
- 服务器端以4字节整数型向客户端传回运算结果。
- 客户端得到运算结果后终止与服务器端的连接。

客户端向服务器端传输的数据结构：

<img src="image\5.1.4.png" alt="1" style="zoom:50%;margin:0px" />



我自己的实现：

- [op_client.c](SK05/My_op_client.c)
- [op_server.c](SK05/My_op_server.c)

书中的实现：

- [op_client.c](SK05/op_client.c)
- [op_server.c](SK05/op_server.c)

运行结果：

```
Connected...........
Operand count: 3
Operand 1: 5
Operand 2: 5
Operand 3: 10
Operator: +
Operation result: 20 
```





## 5.2 TCP原理

### 5.2.1 套接字中I/O缓冲

TCP套接字的数据收发无边界。服务器端即使调用1次write函数传输40字节的数据，客户端也有可能通过4次read函数调用每次读取10字节。但此时也有一些疑问，服务器端一次性传输了40字节，而客户端居然可以缓慢地分批接收。客户端接收10字节后，剩下的30字节再何处等候呢？是不是像飞机为等待着陆而在空中盘旋一样，剩下30字节也在网络中徘徊并等待接收呢？

实际上，write函数调用后并非立即传输数据，read函数调用后，也并非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓存；read函数调用瞬间，从输入缓冲读取数据。

<img src="image\5.2.1.png" alt="1" style="zoom:35%;margin:0px" />

如图5-2所示，调用wirte函数时，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这是对方将调用read函数从输入缓冲读取数据。这些I/O缓冲特性可整理如下：

- I/O缓冲在每个TCP套接字中单独存在。
- I/O缓冲在创建套接字时自动生成。
- 即使关闭套接字也会继续传递输出缓冲中遗留的数据。
- 关闭套接字将丢失输入缓冲中的数据。

那么，下面这种情况会引发什么事情？

> “客户端输入缓冲为50字节，而服务器端传输了100字节。”

结论：

> “不会发生超过输入缓冲大小的数据传输。”

因为TCP会控制数据流。TCP中有滑动窗口协议（Sliding Window）协议，用对话方式呈现如下。

> 套接字A：“你好，最多可以向我传递50字节。”
>
> 套接字B：“OK！”
>
> 
>
> 套接字A：“我腾出了20字节的空间，最多可以收70字节。”
>
> 套接字B：“OK！”

数据收发也是如此，因此TCP中不回因为缓冲溢出而丢失数据。

| 从write函数返回的时间点                                      |
| ------------------------------------------------------------ |
| write函数并不会在完成向对方主机的数据传输时返回，而是在数据移到输出缓冲时。但TCP会保证对输出缓冲数据的传输，所以说write函数在数据传输完成时返回。 |



### 5.2.2 TCP内部工作原理1：与对方套接字的连接

TCP套接字从创建到消失所经过程分成如下3步：

- 与对方套接字建立连接
- 与对方套接字仅需数据交换。
- 断开与对方套接字的连接。

首先讲解与对方套接字建立连接的过程，连接过程中套接字之间的对话如下：

> [Shake 1]套接字A：“你好，套接字B。我这儿有数据要传给你，建立连接吧。”
>
> [Shake 2]套接字B：“好的，我这边已就绪。”
>
> [Shake 3]套接字A：“谢谢你受理我的请求。”

TCP在实际通信过程中也回经过3次对话过程，因此，该过程又称“三次握手”（Three-way handshaking）。

连接过程中实际交换的信息格式：

<img src="image\5.2.2.png" style="zoom:65%;margin:0px" />

套接字是以全双工(Full-duplex)方式工作的。也就是说，它可以双向传递数据。因此，收发数据前需要做一些准备。首先，请求连接的主机A向主机B传递如下信息：

> [SYN] SEQ：1000，ACK：
>
> 该消息中SEQ为1000，ACK为空，而SEQ为1000的含义如下：
>
> > 「 现传递的数据包序号为1000，如果接收无误，请通知我向您传递1001号数据包。」

这是首次请求连接时使用的消息，又称SYN。SYN是Synchronization的简写，表示收发数据前传输的同步消息。接下来主机B向A传递如下消息：

> [SYN + ACK] SEQ：2000，ACK：1001
>
> 此时SEQ为2000，ACK为1001，而SEQ为2000的含义如下：
>
> > 「 现传递的数据包序号为2000，如果接受无误，请通知我向您传递2001号数据包 」
>
> 而ACK1001的含义如下：
>
> > 「 刚才传输的SEQ为1000的数据包接收无误，现在传递SEQ为1001的数据包。」
>
> 对主机A首次传输的数据包的确认消息（ACK1001）和为主机B传输数据做准备的同步消息（SEQ2000）捆绑发送，因此，此种类型的消息又称SYN+ACK。

收发数据前向数据包分配序号，并向对方通报此序号，这都是防止丢失所做的准备。通过向数据包分配序号并确认，可以在数据丢失时马上查看并重传丢失的数据包。因此TCP可以保证可靠的数据传输。最后主机A向主机B传输的消息如下：

> [ACK] SEQ：1001， ACK：2001
>
> 含义如下：
>
> > 「 已正确收到传输的SEQ为2000的数据包，现在可以传输2001的数据包。」

至此，主机A和主机B确认了彼此均就绪。



### 5.2.3 TCP内部工作原理2：与对方主机的数据交换

通过第一步三次握手过程完成了数据交换准备，下面正式开始收发数据：

<img src="image\5.2.3.png" style="zoom:70%;margin:0px" />

上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。

1. 主机A通过1个数据包发送100个字节的数据，数据包的SEQ为1200。

2. 主机B为了确认这一点，向主机A发送ACK1301消息。

   > 传递ACK消息公式：
   >
   > 「 ACK号 = SEQ号 + 传递的字节数 + 1 」
   >
   > 这样可以确认是否100个字节能够完整传递给对方，与三次握手协议相同，最后加1是为了告知对方下次要传递的SEQ号。



下面分析传输过程中数据包丢失的情况：

<img src="image\5.2.3_2.png" style="zoom:68%;margin:0px" />

上图表示通过SEQ 1301数据包向主机B传递100字节数据。但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于SEQ 1301的ACK确认，因此试着重传该数据包。为了完成数据包重传，TCP套接字启动计时器以等待ACK应答。若相应计时器发生超时，则重传。



### 5.2.4 TCP的内部工作原理3：断开与套接字的连接

如果对方还有数据需要传输时直接断掉连接会出问题，所以断开连接时需要双方协商。断开连接时对话如下：

> 套接字A：“我希望断开连接。”
>
> 套接字B：“哦，是吗？请稍后。”
>
> 
>
> 套接字B：“我也准备就绪，可以断开连接。”
>
> 套接字A：“好的，谢谢合作。”

<img src="image\5.2.4.png" style="zoom:55%;margin:0px" />

上图数据包内的FIN表示断开连接。也就是说，双方各发送1次FIN消息后断开连接。此过程经历4个阶段，因此又称「四次握手」。

上图中主机B传递了两次ACK 5001，也许这会让各位感到困惑。其实，第二次FIN数据包中的ACK 5001只是因为接收ACK消息后未接收数据而重传的。



## 5.4 习题

1. 请说明TCP套接字连接设置的三次握手过程。尤其是3次数据交换过程每次收发的数据内容。

   > 答：首先发起连接的套接字发送表示首次建立连接的消息SYN给接收方（套接字），建立连接的消息中有SEQ和ACK字段，表示数据包的序号，和确认是否传输成功的ACK号（首次发起连接无ACK号）。这是第一次握手的过程。然后，接收方套接字将数据包中的SEQ号+1作为ACK号当作来回应，并且告知此接收方发送的网络包为SEQ xxx号，若接收成功则以ACK xxx+1号返回告知。这是第二次握手的过程。最后，当发起连接的套接字收到接收方回应的时，为表示双方已建立连接，则再一次发送消息给接收方，根据接收方SYN+ACK消息，将ACK作为此SEQ号，将接收方数据包的SEQ+1作为此ACK号，传输给接收方。这时，TCP套接字为进行连接操作的三次握手过程就完成了。

2. TCP是可靠的数据传输协议，但在通过网络的过程中可能丢失数据。请通过ACK和SEQ说明TCP通过何种机制保证丢失数据的可靠传输。

   > 答：TCP通过重传机制可以保证数据的可靠传输，其中就要用到检验网络包是否成功无误传输的SEQ和ACK,在传输过程中，每一个数据包都会有一个序号，用SEQ表示数据包的序号，ACK作为确认上一数据包的传输成功的标志，当发送方发现接收方没返回对应的ACK号，发送方将对对应的网络包进行重传，从而实现数据的可靠传输。
   
3. TCP套接字中调用write和read函数时数据如何移动？结合I/O缓冲进行说明。

   > 答：调用write函数不是立马将数据传输到网络中，而是将输出数据移至输出缓冲区中；调用read函数不是立马读取数据，而是从输入缓冲区中读入数据。

4. 对方主机的输入缓冲剩余50字节空间时，若本方主机通过write函数请求传输70字节，请问TCP如何处理这种情况？

   >答：TCP中具有控制数据流的滑动窗口协议，接收方会向发送方提供可发送数据的长度。所以当对方主机剩余50字节空间时，本方主机首先调用write函数将数据移至到输出缓冲区中，根据对方告知的可发送长度，先将50字节传输到对方主机的输入缓冲区中。当对方主机调用read函数，从输入缓冲区中读入数据，就会腾出可利用的空间来继续用来接收，这时对方主机向本方主机告知可以发送的长度，于是输出缓冲区继续将剩余的字节发送到对方的输入缓冲区中，直至70字节的数据传输完毕.

5. 第二章示例tcp_server.c(第一章的hello_server.c)和tcp_client.c中，客户端接收服务器端传输的字符串后便退出。现更改程序，使服务器端和客户端各传递1次字符串。考虑到使用TCP协议，所以传递字符串前先以4字节整数型方式传递字符串长度。连接时服务器端和客户端数据传输格式如下：

   |  0   |  0   |  0   |  6   |  H   |  e   |  l   |  l   |  o   |  ?   |
   | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |

   另外，不限制字符串传输顺序及种类，但须进行3次数据交换。

   > 答：我实现的基于TCP客户端[my_tcp_client.c](SK05/my_tcp_client.c)、服务器端[my_tcp_client.c](SK05/my_tcp_server.c)
   >
   > 客户端运行结果：
   >
   > ```
   > Message from server: Hello? 
   > Message from server: Hello? 
   > Message from server: Hello? 
   > ```
   >
   > 服务器运行结果：
   >
   > ```
   > recieve: Hello?
   > recieve: Hello?
   > recieve: Hello?
   > ```
   >
   > 其中需要留意服务器端可能会多次调用write函数，所以客户端的输入缓冲区中可能有大于6字节的数据，所以调用read函数时，满6字节则停止输入。

   

6. 创建收发文件的服务器端/客户端，实现顺序如下：

   1. 客户端接受用户输入的传输文件名。
   2. 客户端请求服务器端传输该文件名所指文件。
   3. 如果指定文件存在，服务器端就将其发送给客户端；反之，则断开连接。

> 答：我实现的基于TCP协议收发文件客户端/服务器端程序代码如下：
>
> - 客户端：[my_ftp_client.c](SK05/my_ftp_client.c) 
> - 服务器端：[my_ftp_server.c](SK05/my_ftp_server.c)
>
> 客户端运行结果：
>
> ```
> root@iZwz9abtr8fgz78nfnbgjiZ:~/CT# ./mfc 127.0.0.1 5009
> Connected...
> INPUT q/Q TO QUIT!
> download filename:hello
> no this file!
> download filename:low_open.c
> Download Sucessful!
> ```
>
> 服务器端运行结果：
>
> ```
> root@iZwz9abtr8fgz78nfnbgjiZ:~/my_ftp/a# ./mfs 5009                
> Connected...
> filename.len: 5
> filename.len: 10
> Transfer Succesful!
> ```

------



# 第六章 基于UDP的服务器端/客户端

## 6.1 理解UDP

### 6.1.1 UDP套接字的特点

下面通过信件说明UDP的工作原理，这时讲解UDP时使用的传统示例，它与UDP特性完全相符。寄信前应先在信封上填写寄信人和收信人的地址，之后贴上邮票放进邮筒即可。当然，信件的特点使我们无法确认对方是否收到。另外，邮寄过程中也可能发生信件丢失的情况。也就是说信件是一种不可靠的传输方式。与之类似，UDP提供的同样是不可靠的数据传输服务。

> “既然如此，TCP应该是更优质的协议吧？”

如果只考虑可靠性，TCP的确比UDP好。但UDP的结构上比TCP更简洁。UDP不会发送类似ACK的应答消息，也不会像SEQ那样给数据包分配序号。因此，UDP的性能有时比TCP高出很多。编程中实现UDP也比TCP简单。另外，UDP的可靠性虽比不上TCP，但也不会像想象中那么频繁地发生数据损毁。因此，在更重视性能而非可靠性的情况下，UDP是一种很好的选择。

为了提供可靠地数据传输服务，TCP在不可靠的IP层进行流控制，而UDP就缺少这种流控制机制。

> “UDP和TCP的差异只在于流控制机制吗？”

是的，流控制是区分UDP和TCP的最重要的标志。TCP的生命在于流控制，与对方套接字连接及断开连接的过程也属于流控制的一部分。



### 6.1.2 UDP内部工作原理

与TCP不同，UDP不会进行流控制，接下来具体讨论UDP的作用：

<img src="image\6.1.2.png" style="zoom:50%;margin:0px" />

从图中可以看出，IP的作用就是让离开主机B的UDP数据包准确传递到主机A。但把UDP包最终交给主机A的的某一UDP套接字的过程则是由UDP完成的。UDP最重要的作用就是根据端口号将传到主机的数据包交付给最终的UDP套接字。



### 6.1.3 UDP的高效使用

希望各位明白，UDP也具有一定的可靠性。

对于多媒体数据而言，丢失一部分也没有太大问题，这只会引起短暂的画面抖动，或出现细微的杂音。但因为需要提供实时服务，速度就成为非常重要的因素。因此，第5章的流控制就显得有些多余，此时需要考虑使用UDP。

但UDP并非每次都快于TCP，TCP比UDP慢的原因通常有以下两点：

- 收发数据前后进行的连接设置及清除过程。
- 收发数据过程中为保证可靠性而添加的流控制。

如果收发的数据量小但需要频繁连接时，UDP比TCP更高效。



## 6.2 实现基于UDP的服务器端/客户端

### 6.2.1 UDP中的服务器端和客户端没有连接

UDP服务器端/客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程。也就是说，不必调用TCP连接过程中调用的listen函数和accept函数。UDP中只有创建套接字的过程和数据交换的过程。



### 6.2.2 UDP服务器端和客户端均只需1个套接字

TCP中，套接字之间应该是一对一关系。若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。

但在UDP中，不管是服务器端还是客户端都只需要1个套接字。之前解释UDP原理时举了信件的例子，收发信件时使用的邮筒可以比喻为UDP套接字。只要附近有1个邮筒，就可以通过它向任意地址寄出信件。同样只需1个UDP套接字就可以向任意主机传输数据（这里说明UDP套接字不是一对一关系了）。

图6-2展示了1个UDP套接字与2个不同主机交换数据的过程。也就是说，只需1个UDP套接字就能和多台主机通信。

<img src="image\6.2.2.png" alt="1" style="zoom:50%;margin:0px" />





### 6.2.3 基于UDP的数据I/O函数

创建好TCP套接字后，传输数据时无需再添加地址信息。因为TCP套接字将保持与对方套接字的连接。换言之，TCP套接字知到目标地址信息。

但UDP套接字不会保持连接状态（UDP只有简单的邮筒功能），因此每次传输数据都要添加目标地址信息。这相当于寄信前在信件中填写地址。

- 接下来介绍填写地址并传输数据时调用的UDP相关函数：

  ```c
  #include<sys/socket.h>
  ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr * to, socklen_t addrlen);
  ```

  > 成功时返回传输的字节数，失败时返回-1。
  >
  > 参数1：`sock`，用于传输数据的UDP套接字文件描述符
  >
  > 参数2：`buff`，保存待传输数据的缓冲地址值。
  >
  > 参数3：`nbytes`，待传输的数据长度，以字节为单元。
  >
  > 参数4：`flags`，可选项参数，若没有则传递0。
  >
  > 参数5：`to`，存有目标地址信息的sockaddr结构体变量的地址值。
  >
  > 参数6：`addrlen`，传递给参数to的地址值结构体变量长度。

  上述函数与之前的TCP输出函数最大的区别在于，此函数需要向它传递目标地址信息。

  

- 接下来介绍接收UDP数据的函数。UDP数据的发送端并不固定，因此该函数定义为可接受发送端信息的形式，也就是将同时返回UDP数据包中的发送端信息。

  ```c
  #include<sys/socket.h>
  ssize_t recvfrom(int sock, void * buff, size_t nbytes, int flags, struct sockaddr * from, socklen_t * addrlen);
  ```

  > 成功时返回接收的字节数，失败时返回-1。
  >
  > 参数1：`sock`，用于将接受数据的UDP套接字文件描述符
  >
  > 参数2：`buff`，保存接收数据的缓冲地址值。
  >
  > 参数3：`nbytes`，可接收的最大字节数，故无法超过参数buff所指的缓冲大小。
  >
  > 参数4：`flags`，可选项参数，若没有则传入0。
  >
  > 参数5：`from`，存有发送端地址信息的sockaddr结构体变量的地址。
  >
  > 参数6：`addrlen` ，保存参数from的结构体变量长度的变量地址值。

编写UDP程序时最核心的部分就在于上述两个函数，这也说明二者在UDP数据传输中的地位。



### 6.2.4 基于UDP的回声服务器端/客户端

- 服务器端代码参见：[uecho_server.c](SK06/uecho_server.c)

> 需要注意的是，UDP不同于TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端。只是因其提供服务而称为服务器端，请不要误解。

- 编译运行：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# gcc uecho_server.c -o userver
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# ./userver 5009
  ```

  

- 客户端代码参见：[uecho_client.c](SK06/uecho_client.c)

  > 与TCP客户端不同，UDP不存在connect函数调用
  >
  > 读上述代码时应有如下疑问：
  >
  > - 问：“TCP客户端套接字在调用connect函数是自动分配IP地址和端口号，既然如此，UDP客户端何时分配IP地址和端口号？”
  >
  >   
  >
  > - 答：“所有套接字都应分配IP地址和端口，问题是直接分配还是自动分配，之后将会讨论到。”

- 编译运行：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# gcc uecho_client.c -o uclient
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# ./uclient 127.0.0.1 5009
  Insert messgae(q) to quit): hello
  Message from server: hello
  Insert messgae(q) to quit): 12345
  Message from server: 12345
  Insert messgae(q) to quit): q
  ```
  
  

### 6.2.5 UDP客户端套接字的地址分配

如果仔细观察UDP客户端会发现，它缺少把IP和端口分配给套接字的过程。TCP客户端调用connect函数自动完成此过程，而UDP中连能承担相同功能的函数调用语句都没有。究竟在何时分配IP和端口号呢？

UDP程序中，客户端调用sendto函数传输数据前，服务器端应完成对套接字的地址分配工作，因此调用bind函数。bind函数不区分TCP和UDP。

如果调用sendto函数时发现尚未分配地址信息，则在首次调用sendto函数时给相应套接字自动分配IP和端口。而且此时分配的地址一直保留到程序结束为止，因此也可用来与其他UDP套接字进行数据交换。

综上所述，调用sendto函数时自动分配IP和端口号，因此，UDP客户端中通常无需额外的地址分配过程。所以之前示例中省略了该过程，这也是普遍的实现方式。



## 6.3 UDP的数据传输特性和调用connect函数

我们之前通过示例验证了TCP传输的数据不存在数据边界，本节将验证UDP数据传输中存在数据边界。最后讨论UDP中connect函数的调用。

### 6.3.1 存在数据边界的UDP套接字

UDP具有数据边界的协议，传输中调用I/O函数的次数非常重要。因此，输入函数的调用次数应和输出函数的调用次数完全一致，这样才能保证接收全部已发送数据。例如，调用3次输出函数发送的数据必须通过调用3次输入函数才能接收完。下面通过简单示例进行验证。

示例代码参见：

- 服务器端：[bound_host1.c](file:///F:\share_ftp\SK\SK06/bound_host1.c)
- 客户端：[bound_host2.c](file:///F:\share_ftp\SK\SK06/bound_host2.c)

> bound_host2.c程序3次调用sendto函数以传输数据，bound_host1.c则调用3次recvfrom函数以接收数据。recvfrom函数调用间隔为5秒，因此，调用recvfrom函数前已经调用3次sendto函数。也就是说，此时数据已经传输到bound_host1.c。如果是TCP程序，这时只需调用1次输入函数即可读入数据。UDP则不同，在这种情况下也要调用3次recvfrom函数。可以通过以下运行结果进行验证。

- 编译bound_host1.c:

  ```
  gcc bound_host1.c -o host1
  ./host1 5009
  ```

- 编译bound_host2.c

  ```
  gcc bound_host2.c -o host2
  ./host2 127.0.0.1 5009
  ```



- bound_host1.c 运行结果

  ```
  Message 1: Hi! 
  Message 2: I'm another UDP host! 
  Message 3: Nice to meet you 
  ```

  > 从运行结果来看，可以看出共调用了3次recvfrom函数。这就证明必须在UDP通信过程中使用I/O函数调用次数保持一致。



### 6.3.2 已连接（connected）UDP套接字与未连接（unconnected）UDP套接字

TCP套接字中需注册待传输数据的目标IP和端口，而UDP中则无需注册。因此，通过sendto函数传输数据的过程大致可分为以下3个阶段：

- 第1阶段：向UDP套接字注册目标IP和端口号
- 第2阶段：传输数据。
- 第3阶段：删除UDP套接字中注册的目标地址信息。

每次调用sendto函数时重复上述过程。每次都要变更目标地址，因此可以重复利用同一UDP套接字向不同目标传输数据。

这种未注册目标信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接connected套接字。显然，UDP套接字默认属于未连接套接字。但UDP套接字在下述情况下显得不太合理：

>“IP为211.210.147.82的主机82号端口共准备了3个数据，调用3次sendto函数进行传输。”

此时需重复3次上述三个阶段。因此，要与同一主机进行长时间通话时，将UDP套接字变成已连接套接字会提高效率。上述三个阶段中，第一个和第三个阶段占整个通信过程近1/3的时间，缩短这部分时间将大大提高整体性能。



### 6.3.3 创建已连接UDP套接字

创建已连接UDP套接字的过程格外简单，只需针对UDP套接字调用connect函数。

```c
sock = socket(PF_INET, SOCK_DGRAM, 0);
memset(&adr, 0, sizeof(adr));
adr.sin_family = AF_INET;
adr.sin_addr.s_addr = ......
adr.sin_adr_port = ......
connect(sock, (struct sockaddr*)&adr, sizeof(adr));
```

> 通过调用connect函数，向UDP套接字注册目标IP和端口号信息。

之后就与TCP套接字一样，每次调用sendto函数时只需传输数据。因为已经指定了收发对象，所以不仅可以使用sendto、recvfrom函数，还可以使用write、read函数进行通信。

将uecho_client.c程序改成基于已连接UDP套接字的程序：

程序代码参见：[uehco_con_client.c](SK06/uecho_con_client.c)





## 6.5 习题

1. UDP为什么比TCP速度快？为什么TCP数据传输可靠而UDP数据传输不可靠？

   > 答：速度上：①UDP不是面向连接的协议，所以UDP少了进行请求连接的过程。②TCP中具有流控制机制，而UDP不具有流控制，所以UDP结构更简洁，在一定程度上提高了传输的速度；可靠性上：TCP具有重传机制、流控制机制保证数据的可靠传输，而UDP不提供可靠的传输服务。

2. 下列不属于UDP特点的是？

   **a.UDP不同于TCP，不存在连接的概念，所以不像TCP那样只能进行一对一的数据传输。**

   b.利用UDP传输数据时，如果有2个目标，则需要2个套接字。

   c.UDP套接字中无法使用已分配TCP的同一端口号。

   **d.UDP套接字和TCP套接字可以共存。若需要，可以在同一主机进行TCP和UDP数据传输。**

   e.针对UDP函数也可以调用connect函数，此时UDP套接字跟TCP套接字相同，也需要经过3次握手过程。

   > 答：不属于UDP特点：b，c，e
   >
   > e的理解：UDP调用connect函数只是用来注册目标套接字的网络地址信息来实现「已连接套接字」，并不是像TCP那样创建连接。

3. UDP数据报向对方主机的UDP套接字传递过程中，IP和UDP分别负责哪些部分？

   > 答：IP的作用就是让离开主机的UDP数据包准确传递到另一个主机。但把UDP包最终交给主机的某一UDP套接字的过程则是由UDP完成的。UDP的最重要的作用就是根据端口号将传到主机的数据报交付给最终的UDP套接字。

4. UDP一般比TCP快，但根据交换数据的特点，其差异可大可小。请说明何种情况下UDP的性能优于TCP？

   > 答：UDP性能优于TCP的情况：①短时间内的数据交换；②对传输速度要求高的实时环境。如果收发数据量小但需要频繁连接时，UDP比TCP更高效。（频繁的理解：持续的反义词）

5. 客户端TCP套接字调用connect函数时自动分配IP和端口号。UDP中不调用bind函数，那何时分配IP和端口号？

   > 答：当首次调用sendto函数的时候，将会自动给UDP套接字分配IP地址和端口号，而且此时分配的地址一直保留到程序结束为止。

6. TCP客户端必须调用connect函数，而UDP中可以选择性调用。请问，在UDP中调用connect函数有哪些好处？

   > 答：当重复性地向同一接收方进行数据交换时，调用connect函数可以减少重复注册目标的网络地址信息和删除UDP套接字中注册的目标地址信息这两个阶段的过程。在这种情况下调用connect函数从而有利于提高传输性能。

7. 请参考本章给出的uecho_server.c和uecho_client.c，编写示例使服务器端和客户端轮流收发消息。收发的消息均要输出到控制台窗口。

   > 答：我实现的基于UDP的客户端和服务器端如下：
   >
   > - 客户端：[my_udp_con_client.c](SK06/my_udp_con_client.c)
   > - 服务器端：[my_udp_con_server.c](SK06/my_udp_con_server.c)
   >
   > 编译运行客户端程序：
   >
   > >```
   > >root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# ./mucclient 127.0.0.1 5009      
   > >input q or Q to quit
   > >send: Hi server!
   > >recv: Hello client!
   > >send: How are you?
   > >recv: fine, thank you!
   > >send: q
   > >```
   > >
   > >
   >
   > 编译运行服务器端程序：
   >
   > >```
   > >root@iZwz9abtr8fgz78nfnbgjiZ:~/SK06# ./mucserver 5009
   > >input q or Q to quit
   > >recv: Hi server!
   > >send: Hello client!
   > >recv: How are you?
   > >send: fine, thank you!
   > >```
   >
   > 运行程序后首先由客户端发起消息，因为当客户端传输消息给服务器的时候，服务器才能获知客户端的网络地址信息，才能够进行双向对话，此过程是轮流收发消息，每次只能输出一条字符串，这就是单线程的局限性。
   
   
   
   另外，提供TCP版本：
   
   > - 客户端：[my_tcp_con_client.c](SK06/my_tcp_con_client.c)
   > - 服务器端：[my_tcp_con_server.c](SK06/my_tcp_con_server.c)
   
   ------





# 第七章 优雅地断开套接字连接

------

之前用的方法不够优雅是因为，我们是调用close或`closesocket`函数单方面断开连接的。只有掌握了下面讲解的半关闭（Half-close），才能明确断开过程。

## 7.1基于TCP的半关闭

### 7.1.1单方面断开连接带来的问题

Linux的`close`函数和Windows的`closesocket`函数意味着完全断开连接。完全断开不仅无法传输数据，而且也不能接收数据。因此，在某些情况下，通信一方调用`close`或`closesocket`函数断开连接就显得不太优雅。

<img src="image\7.1.1.png" alt="1" style="zoom:45%;margin:0px" />

上图描述的是2台主机正在进行双向通信。主机A发送完最后的数据后，调用close函数断开了连接，之后主机A无法再接收主机B传输的数据，因为断开后主机A完全无法调用接收数据的函数。最终，由主机B传输的、主机A必须接收的数据也销毁了。

为了解决这类问题，「只关闭一部分数据交换中使用的流（Half-close）」的方法应运而生。断开一部分连接是指，可以传输数据但无法接收，或可以接收数据但无法传输。顾名思义就是之关闭流的一半。



### 7.1.2 套接字和流（Stream）

两台主机通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看作一种流。

此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向移动。因此，为了进行双向通信，需要下图所示的2个流：

<img src="image\7.1.2.png" alt="1" style="zoom:55%;margin:0px" />

一旦两台主机间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一台主机的输出流相连，而输出流则与另一主机的输入流相连。另外，本章讨论的“优雅地断开连接方式”之断开其中1个流，而非同时断开两个流。Linux的close和Windows的closesocket函数将同时断开这两个流，因此与“优雅”二字还有一段距离。



### 7.1.3 针对优雅断开的shutdown函数

- 接下来介绍用于半关闭的函数。下面这个shutdown函数就用来关闭其中1个流。

  ```c
  #include<stdio.h>
  int shutdown(int sock, int howto);
  ```

  > 成功时返回0，失败时返回-1。
  >
  > 参数1：sock，需要断开的套接字文件描述符
  >
  > 参数2：howto，传递断开方式信息。

  |          第二参数           | 断开连接的方式 |
  | :-------------------------: | -------------- |
  |          `SHUT_RD`          | 断开输入流     |
  |          `SHUT_WR`          | 断开输出流     |
  | `SHUT_RDWR`（记忆：“读写”） | 同时断开I/O流  |

  1）若向shutdown的第二个参数传递`SHUT_RD`，则断开输入流，套接字无法接收数据。即使输入缓冲收到的数据也会抹去，而且无法调用输入相关函数。

  2）如果向shutdown函数的第二个参数传递`SHUT_WR`，则中断输出流，也就无法传输数据。但如果输出缓冲还留有未传输的数据，则将传递至目标主机。

  3）最后，做传入`SHUT_RDWR`，则同时终端I/O流。这相当于分2次调用shutdown，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数。



### 7.1.4 为何需要半关闭

相信各位已对“半关闭套接字的一半连接”有了充分的认识，但还有一些疑惑。

> “究竟为什么需要半关闭?是否只要留出足够长的时间，保证完成数据交换即可？只要不急于断开连接，好像也没必要使用半关闭？”

这句话也不完全是错的。如果保持足够的时间间隔，完成数据交换后再断开连接，这时就没必要使用半关闭。但要考虑如下情况：

> “一旦客户端连接到服务器端，服务器端就将约定的文件传给客户端，客户端收到后发送字符串‘Thank you’给服务器端。”

此处字符串“Thank you”的传递实际是多余的，这只是用来模拟客户端断开连接前还有数据需要传递的情况。此时程序实现的难度并不小，因为传输文件的服务器端只需连续传输文件数据即可，而客户端则无法知道需要接收数据到何时。客户端也没办法无休止地调用输入函数，因为这有可能导致程序阻塞（调用的函数未返回）。

> “是否可以让服务器端客户端约定一个代表文件尾的字符？”

这种方式也有问题，因为这意味着文件中不能够与约定字符相同的内容。为了解决该问题，服务器端应最后向客户端传递EOF表示文件传输结束。客户端通过函数返回值接收EOF，这样可以避免与文件内容冲突。剩下最后一个问题：服务器如何传递EOF？

> “断开输出流时向对方主机传输EOF。”

当然调用close函数的同时关闭I/O流，这样也会向对方发送EOF。但此时无法在接收对方的传输的数据。换言之，若调用close函数关闭流，就无法接收客户端最后发送的字符串“Thank you”。这时需要调用shutdown函数，只关闭服务器的输出流（半关闭）。这样既可以发送EOF，同时有保留了输入流。可以接收对方数据。

下面结合已学内容实现收发文件的服务器端/客户端。



### 7.1.5 基于半关闭的文件传输程序

上述文件传输服务器端和客户端的数据流可以整理成如下图：

<img src="image\7.1.5.png" style="zoom:55%;margin:0px" />

首先介绍服务器端，该示例省略了大量错误处理代码，这种处理只是为了便于分析代码，实际编写中不应省略。

- 服务器端：[file_server.c](SK07/file_server.c)
- 客户端：[file_client.c](SK07/file_client.c)



- file_server.c运行结果：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK07# gcc file_server.c -o fserver
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK07# ./fserver 5009
  Message from client: Thank you 
  ```

- file_client.c运行结果：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK07# gcc file_client.c -o fclient
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK07# ./fclient 127.0.0.1 5009
  Received file data
  ```

  最后，客户端主机中可以看到服务器端传来的文件。



## 7.3 习题

1. 解释TCP中“流”的概念。UDP中是否形成流?请说明原因。

   > 答：TCP中的“流”是两台主机通过建立套接字连接而形成的，流是单向传输的数据，其中包括输入流和输出流。UDP不是面向连接的，没有建立连接的过程，所以UDP中不能形成流。
   >
   > 

2. Linux中的close函数或Windows中的closesocket函数属于单方面断开连接的办法，又可能带来一些问题。什么是单方面断开连接?什么情形下会出现问题？

   > 答：单方面断开连接就是

3. 什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么消息？

   > 答：半关闭，顾名思义就是关闭流的一半，可以是关闭接收输入流，也可以是关闭发送输出流。
   >
   > 输出流半关闭的主机此时只能从输入缓冲区中接收数据，不能将数据传输到输出缓冲区中。输出流半关闭会导致对方主机接收到EOF，表示文件传输结束。

------





# 第八章 域名及网络地址

------

## 8.1 域名系统

DNS是对IP地址和域名进行相互转换的系统，其核心是DNS服务器

### 8.1.1 什么是域名

域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类易理解的信息。

### 8.1.2 DNS服务器

相当于一个字典，可以查询出某一个域名对应的IP地址

<img src="image\8.1.2_1.png" style="zoom:68%;margin:0px;" />



## 8.2 IP地址和域名之间的转换

### 8.2.1 程序中有必要使用域名吗？

一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的。

### 8.2.2 利用域名获取IP地址

使用以下函数可以通过传递字符串格式的域名获取IP地址。

```c
#include<netdb.h>
struct hostent * gethostbyname(const char * hostname);
```

> 成功时返回hostent结构体地址，失败时返回NULL指针。

这个函数使用方便。只要传递域名字符串，就会返回域名对应的IP地址。只是返回时，地址信息装入hostent结构体。此结构体定义如下：

```c
struct hostent
{
	char * h_name;		//official name
	char ** h_aliases;	//alias list
	int h_addrtype;		//host address type
	int h_length;		//address length
	char ** h_addr_list; //address list
}
```

从上述结构体定义中可以看出，不只返回IP信息，同时还连带着其他成员。各位不用显得太过复杂。域名转IP时只需关注h_addr_list。

- h_name

  该变量中存有官方域名（Official domain name）。

- h_aliases

  可以通过多个域名访问同一主页。同一IP可以绑定多个域名，因此，除官方域名外还可指定其他域名。这些信息可以通过h_aliases获得。

- h_addrtype

  gethostbyname函数不仅支持IPv4，还支持IPv6。因此可以通过此变量获取保存在h_addr_list的IP地址的地址族信息。若是IPv4，则此变量存有AF_INET。

- h_length

  保存IP地址长度。若是IPv4地址，因为是4个字节，则保存4；IPv6时，因为是16个字节，故保存16。

- h_addr_list

  这是最重要的成员。通过此变量以整数形式保存域名对应的IP地址。另外用户较多的网站有可能分配多个IP给同一域名，利用多个服务器进行负载均衡。此时同样可以通过此变量获取IP地址信息。
  
  

调用gethostbyname函数后返回hostent结构体的变量结构如下图所示：

<img src="image\8.2.2.png" style="zoom:65%;margin:0px;" />

> 该图在实际编程中非常有用，结合hostent结构体定义加以理解

下面的代码通过一个例子来演示gethostbyname的应用：

- 程序代码：[gethostbyname.c](SK08/gethostbyname.c)

- 运行结果：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK08# ./hostname www.bilibili.com
  Official name: g.w.bilicdn1.com 
  Aliases 1: www.bilibili.com 
  Aliases 2: a.w.bilicdn1.com 
  Address type: AF_INET 
  IP addr 1: 139.159.252.156 
  IP addr 2: 139.159.241.37 
  IP addr 3: 110.43.33.166 
  IP addr 4: 110.43.34.66 
  IP addr 5: 110.43.34.184
  ```



若只看hostent结构体的定义，结构体成员`h_addr_list`指向字符串指针数组（由多个字符串地址构成的数组）。但字符串指针数组中的元素实际指向的是（实际保存的是）`in_addr`结构体变量地址值而非字符串，如下图：

<img src="image\8.2.2_1.png" style="zoom:50%;margin:0px;" />

正因如此，示例的第28行需要进行类型转换，并调用inet_ntoa函数。

```c
inet_ntoa(*(struct in_addr*)host->h_addr_list[i]));
```

> in_addr结构体的声明可以参考第三章。

| 为什么是char*而不是in_addr*                                  |
| ------------------------------------------------------------ |
| hostent结构体的成员h_addr_list指向的数组类型并不是in_addr结构体的指针数组，而是采用了char指针。各位也许对这一点感到困惑，但我认为大家应该能料到。hostent结构体并非只为IPv4准备。h_addr_list指向的数组中也可以保存IPv6地址信息。因此，考虑到通用性，声明为char指针类型的数组。 |



### 8.2.3 利用IP地址获取域名

gethostbyaddr函数利用IP地址获取域相关信息。

```c
#include<netdb.h>
struct hostent * gesthostbyaddr(const char * addr, socklen_t len, int family) ;
```

> 成功时返回hostent结构体变量地址值，失败时返回NULL指针。
>
> 参数1：`addr`，含有IP地址信息的`in_addr`结构体指针。 为了同时传递IPv4地址之外的其他信息，该变量的类型声明为char指针。
>
> 参数2：`len`，向第一个参数传递的地址信息的字节数，IPv4时为4，IPv6时为16。
>
> 参数3：family，传递地址族信息，IPv4时为AF_INET，IPv6时为AF_INET6。



下面通过代码演示gesthostbyaddr函数的调用方法：

- 代码参见：[gethostbyaddr.c](SK08/gethostbyaddr.c)

- 运行结果：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK08# ./hostaddr 139.159.252.156
  Official name: ecs-139-159-252-156.compute.hwclouds-dns.com 
  Address type: AF_INET 
  IP addr 1: 139.159.252.156
  ```



## 8.4 习题

1. 下列关于DNS的说法错误的是？

   **a.因为DNS存在，故可以用域名替代IP。**

   b.DNS服务器实际上是路由器，因为路由器根据域名决定数据路径

   **c.所有域名信息并非集中于1台DNS服务器，但可以获取某一DNS服务器中未注册的IP地址。**

   d.DNS服务器根据操作系统进行区分，Windows下的DNS服务器和Linux下的服务器是不同的。

   > 答：以上加粗字体表示正确。

2. 阅读如下对话，并说明东秀的方案是否可行？

   <img src="image\8.4.png" alt="1" style="zoom:50%;margin:0px" />

   > 答：东秀的方案是可行的，DNS服务器是分布式的，一台坏了可以找其他的。

3. 在浏览器地址输入www.orentec.co.kr,并整理出主页显示过程。假设浏览器访问的默认DNS服务器中并没有关于www.orentec.co.kr的IP地址信息。

   > 答：可以参考知乎回答，[再浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤](https://www.zhihu.com/question/34873227/answer/518086565)。谈谈自己对DNS服务器查询IP地址所对应域名的了解。浏览器会向最近的一个DNS服务器查询是否有该域名对应的IP地址信息，如果DNS服务器中没有记录，DNS服务器就会向根服务器进行查询请求，根服务器会根据URL中的信息，向下面的DNS服务器发起询问，直到找到域名所对应的IP地址后，将IP地址返回给浏览器。

------





# 第九章 套接字的多种可选项

## 9.1 套接字可选项和I/O缓冲大小

我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也十分重要。

### 9.1.1 套接字多种可选项

|   协议层    |      选项名       | 读取 | 设置 |
| :---------: | :---------------: | :--: | :--: |
| SOL_SOCKET  |     SO_SNDBUF     |  O   |  O   |
| SOL_SOCKET  |     SO_RCVBUF     |  O   |  O   |
| SOL_SOCKET  |   SO_REUSERADDR   |  O   |  O   |
| SOL_SOCKET  |   SO_KEEPALIVE    |  O   |  O   |
| SOL_SOCKET  |   SO_BROADCAST    |  O   |  O   |
| SOL_SOCKET  |   SO_DONTROUTE    |  O   |  O   |
| SOL_SOCKET  |   SO_OOBINLINE    |  O   |  O   |
| SOL_SOCKET  |     SO_ERROR      |  O   |  X   |
| SOL_SOCKET  |      SO_TYPE      |  O   |  X   |
| IPPROTO_IP  |      IP_TOS       |  O   |  O   |
| IPPROTO_IP  |      IP_TTL       |  O   |  O   |
| IPPROTO_IP  | IP_MULTICAST_TTL  |  O   |  O   |
| IPPROTO_IP  | IP_MULTICAST_LOOP |  O   |  O   |
| IPPROTO_IP  |  IP_MULTICAST_IF  |  O   |  O   |
| IPPROTO_TCP |   TCP_KEEPALIVE   |  O   |  O   |
| IPPROTO_TCP |    TCP_NODELAY    |  O   |  O   |
| IPPROTO_TCP |    TCP_MAXSEG     |  O   |  O   |

从上表中可以看出，套接字选项是分层的。

- IPPROTO_IP层可选项是IP协议相关事宜
- IPPROTO_TCP层可选项是TCP协议相关的事项
- SOL_SOCKET层是套接字相关的通用可选项。



### 9.1.2 getsockopt & setsockopt

我们几乎可以针对上表中的所有可选项进行读取（Get）和设置（Set）（有些可选项只能进行一种操作）。可选项的读取和设置通过如下2个函数完成。

```c
#include<sys/socket.h>
int getsockopt(int sock, int level, int optname, void *optval, socklen_t * optlen);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：`sock`，用于查看选项套接字文件描述符。
>
> 参数2：`level`，要查看的可选项的协议层。
>
> 参数3：`optname`，要查看的可选项名。
>
> 参数4：`optval`，保存查看结果的缓冲地址值。
>
> 参数5：`optlen`，向第四个参数optval传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。

上述函数用于读取套接字可选项，并不难。接下来介绍更改可选项时调用的函数。

```c
#include<sys/socket.h>
int setsockopt(int sock, int level, int optname, const void * optavl, socklen_t optlen);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：`sock`，用于更改可选项的套接字文件描述符。
>
> 参数2：`level`，要更改的可选项协议层。
>
> 参数3：`optname`，要更改的可选项名。
>
> 参数4：`optavl`，保存要更改的选项信息的缓冲地址值。
>
> 参数5：`optlen`，向第四个参数optval传递的可选项信息的字节数。

接下来介绍这些函数的调用方法。关于setsockopt函数的调用方法在其他示例中给出，先介绍getsockopt函数的调用方法。下列示例用协议层为SQL_SOCKET、名为SO_TYPE的可选项查看套接字类型（TCP或UDP）。

- 代码参见：[sock_type.c](SK09/sock_type.c)

- 运行结果：

  ```
  SOCK_STREAM: 1 
  SOCK_DGRAM: 2 
  Socket type one: 1 
  Socket type two: 2 
  ```

上述示例给出了调用getsockopt函数查看套接字信息的方法。另外，用于验证套接字类型的SO_TYPE是经典的只读可选项，这一点可以通过下面这句话解释：

> “套接字类型只能在创建时决定，以后不能再更改。”



### 9.1.3  SO_SNDBUF & SO_RCVBUF

前面介绍过，创建套接字将同时生成I/O缓冲。

- SO_RCVBUF是输入缓冲大小相关可选项。(记忆：RCV：receive，输入； BUF：缓冲)
- SO_SNDBUF是输出缓冲大小相关可选项。(记忆：SND：send， 输出；BUF：缓冲)

用这2个可选项既可以读取I/O缓冲大小，也可以进行更改。通过下列示例读取创建套接字默认的I/O缓冲大小。

- 代码参见：[get_buf.c](SK09/get_buf.c)

- 运行结果：

  ```
  Input buffer size: 131072 
  Output buffer size: 16384 
  ```

这时我系统中运行的结果，与各位的运行结果相比可能有些较大差异。



接下里的程序中将更改I/O缓冲大小。

- 代码参见：[set_buf.c](SK09/set_buf.c)

- 运行结果：

  ```
  Input buffer size: 6144 
  Output buffer size: 6144 
  ```

输出结果跟我们预想的完全不同，但也算合理。缓冲大小的设置需谨慎处理，因此不会完全按照我们的要求进行，只是通过调用setsockopt函数向系统传递我们的要求。如果把输出缓冲设置为0并如实反馈这种设置，TCP协议将如何进行？如果要实现流控制和错误发生时的重传机制，至少要有一些缓冲空间吧。但也大致反映出通过setsockopt函数设置的缓冲大小。



## 9.2 SO_REUSEADDR

本节的可选项SO_REUSEADDR及相关的Time-wait状态很重要。

### 9.2.1 发生地址分配错误（Binding Error）

学习SO_REUSEADDR可选项之前，应理解好Time-wait状态。

- 服务器代码参见：[reuseadr_eserver.c](SK09/reuseadr_eserver.c)

  > 这是一个回声服务器端代码，配合下面第四章的echo_client.c使用

- 客户端代码参见：[echo_client.c](SK09/echo_client.c)（此示例是之前实现的回声客户端）

通过以下方式终止程序：

> “再客户端控制台输入Q消息，或通过<kbd>CTRL</kbd>+<kbd>C</kbd>终止程序。”

也就是说，让客户端先通知服务器端终止程序。在客户端控制台输入Q消息时调用close函数，向服务器端发送FIN消息，向服务器端发送FIN消息并经过四次握手过程。当然，输入<kbd>CTRL</kbd>+<kbd>C</kbd>时会向服务器传递FIN消息。强制终止程序时，由操作系统关闭文件及套接字，此过程相当于调用close函数，也会向服务器端传递FIN消息。

> “但看不到什么特殊现象啊？”

是的，通常都是由客户端先请求断开连接，所以不会发生特别的事情。重新运行服务器端也不成问题，但按照如下方式终止程序时则不同。

> “服务器端和客户端已建立连接的状态下，向服务器端控制台输入<kbd>CTRL</kbd>+<kbd>C</kbd>，及强制关闭服务器端。”

这主要模拟了服务器端向客户端发送FIN消息的情景。但如果以这种方式终止程序，那服务器端重新运行时将产生问题。如果用同一端口号重新运行服务器端，将输出“bind() error”消息，并且无法再次运行。但在这种情况下，再过大约3分钟即可重新运行服务器端。

上述2中运行方式唯一的区别就是谁先传输FIN消息，但结果却迥然不同，原因何在呢？



### 9.2.2 Time-wait 状态

四次挥手的过程：

<img src="image\9.2.2.png" alt="1" style="zoom:75%;margin:0px" />

假设上图9-1中主机A是服务器端，因为是主机A向B发送FIN消息，故可以想象成服务器端在控制台输入<kbd>CTRL</kbd>+<kbd>C</kbd>。但问题是，套接字经过四次挥手过程后并非立即消除，而是要经过一段时间的Time-wait状态。当然，只有先断开连接（先发送FIN消息的）主机才经过Time-wait状态。因此，若服务器端先断开，则无法立即重新运行。套接字处在Time-wait过程中，相应端口是正在使用的状态。因此，就像之前验证过的，bind函数调用过程中当然会发生错误。

| 客户端套接字不会经过Time-wait过程吗？                        |
| ------------------------------------------------------------ |
| 有些人会误以为Time-wait过程只存在于服务器端。但实际上，不管是服务器端还是客户端，套接字都会有Time-wait过程。先断开连接的套接字必然会经过Time-wait过程。但无需考虑客户端Time-wait状态。因为客户端套接字的端口号是任意指定的。与服务器端不同，客户端每次运行程序时都会动态分配端口号，因此无需过多关注Time-wait状态。 |

| 到底为什么会有Time-wait状态呢？                              |
| ------------------------------------------------------------ |
| 上图9-1中假设主机A向主机B传输ACK消息（SEQ 5001、ACK 7502）后立即消除套接字 。但最后这条ACK消息在传递途中丢失，未能传给主机B。这时会发生什么？主机B会认为之前自己发送的FIN消息（Seq 7501、ACK 5001）未能抵达主机A，继而试图重传。但此时主机A已是完全终止的状态，因此主机B永远无法收到主机A最后传来的ACK消息。相反，若主机A的套接字处在Time-wait状态，则会向主机B重传最后的ACK消息，主机B也可以正常终止。基于这些考虑，先传输FIN消息的主机应经过Time-wait过程。 |



### 9.2.3 地址再分配

Time-wait看似重要，但并不一定讨人喜欢。考虑一下系统发生故障从而紧急停止的情况。这时需要尽快重启服务器端以提供服务，但因处于Time-wait状态而必须等待几分钟。因此，Time-wait并非只有优点，而且有些情况下可能引发更大问题。

下图演示了四次挥手时不得不延长Time-wait过程的情况：

<img src="image\9.2.3.png" style="zoom:75%;margin:0px" />

如图所示，再主机A的四次挥手过程中，如果最后的数据丢失，则主机B会认为主机A未能收到自己发送的FIN消息，因此重传。这时，收到FIN消息的主机A将重启Time-wait计时器。因此，如果网络状况不理想，Time-wait状态将持续。

解决方案就是在套接字的可选项中更改SO_REUSEADDR的状态。适当调整该参数，可将Time-wait状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR的默认值为0（假），这就意味着无法分配Time-wait状态下的套接字端口号。因此需要将这个值改成1（真）。具体做法已在示例[reuseadr_eserver.c](SK09/reuseadr_eserver.c)中给出，只需去掉下述代码的注释即可。

```c
optlen = sizeof(option);
option = TRUE;
setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (void*)&option, optlen);
```

服务器端此时已变成可随时运行的状态。



## 9.3 TCP_NODELAY

“什么是Nagle算法？使用该算法能够获得哪些数据通信特性？”

下面对Nagle算法进行详细讲解。

### 9.3.1 Nagle算法

为防止因数据包过多而发生网络过载，Nagle算法在1984年诞生了。它应用于 TCP层，非常简单。其使用与否，会导致如下图所示的差异：

<img src="image\9.3.1.png" style="zoom:55%;margin:0px;" />

上图展示了通过Nagle算法发送字符串“Nagle”和未使用Nagle算法的差别。可以得到如下结论：

> “只有收到前一数据的ACK消息时，Nagle算法才发送下一数据。”

- 上图左侧：

  TCP套接字默认使用Nagle算法交换数据，因此最大限度地进行缓冲，直到收到ACK。为了发送字符串“Nagle”，将其传递到输出缓冲。这时头字符“N”之前没有其他数据（没有需接收的ACK），因此立即传输。之后开始等待字符“N”的ACK消息，等待过程中，剩下的“agle”填入输出缓冲。接下来，收到“N”的ACK消息后，将输出缓冲的“agle”转入一个数据包发送。也就是说，共需传递4个数据包（2SEQ + 2ACK）以传输1个字符串。

  

- 上图右侧

  假设字符“N”到“e”依序传到输出缓冲。此时的发送过程与ACK接收无关，因此数据到达输出缓冲后立即被发送出去。从图右侧可以看到，发送字符串“Nagle”时共需10个数据包。由此可知，不使用Nagle算法将对网络流量（Traffic：之网络负载或混杂程度）产生负面影响。即使只传输1个字节数据，其头信息都有可能是几十个字节。因此，为了提高网络传输效率，必须使用Nagle算法。

| 图9-3是极端情况的演示                                        |
| ------------------------------------------------------------ |
| 在程序中将字符串传给输出缓冲时并不是逐字传递的，故发送字符串“Nagle”的实际情况并非如图9-3所示。但如果隔一段时间再把构成字符串的字符传到输出缓冲（如果存在此类数据传递）的话，则有可能产生类似图9-3的情况。图9-3中就是隔一段时间向输出缓冲传递待发送数据的。（就是多次调用write()） |

| 对Nagle算法的理解：                                          |
| ------------------------------------------------------------ |
| Nagle算法的作用：充分利用缓冲区的空间，来减少网络传输中的数据包，进而在一定情况下可以提高网络传输效率。Nagle算法在网络环境不稳定的条件下，可以考虑使用。如果传输大文件数据，则使用Nagle算法和不使用Nagle算法的差别不大，网络中的数据包并没有减少多少，因为将文件传入输出缓冲区不会花太多时间，也能填满输出缓冲时传输数据包，而且无需等待ACK的前提下连续传输，因此可以大大提高传输速度。 |

Nagle算法并不是什么时候都适用。根据传输数据的特性，网络流量未受到太大影响时，不使用Nagle算法要比使用它时传输速度快。最典型的是“传输大文件数据”。将文件数据传入输出缓冲不会花太多时间，因此，即便不使用Nagle算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而会在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。

一般情况下，不使用Nagle算法可以提高传输速度。但如果无条件放弃Nagle算法，就会增加过多的网络流量，反而会影响传输。因此，为准确判断数据特性时不应禁用Nagle算法。

关于这个算法，可以参考这个回答：[TCP连接中启用和禁用TCP_NODELAY有什么影响?](https://www.zhihu.com/question/42308970/answer/246334766)



### 9.3.2 禁用Nagle算法

刚才说过的“大文件数据”应禁用Nagle算法。换言之，如果有必要，就应禁用Nagle算法。

> “传输大文件数据时使用Nagle算法与否在网络流量上差别不大，使用Nagle算法的传输速度变慢。”

禁用方法非常简单。只需将套接字可选项TCP_NODELAY改为1（真）即可。

- 禁用方法：

  ```c
  int opt_val = 1;
  setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*)&opt_val, sizeof(opt_val));
  ```

- 另外，可以通过TCP_NODELAY值查看Nagle算法的设置状态：

  ```c
  int opt_val;
  socklen_t opt_len;
  opt_len = sizeof(opt_val);
  getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*)&opt_val, &opt_len);
  ```

  如果正在使用Nagle算法，opt_val变量中会保存0；

  如果已禁用Nagle算法，则保存1；

  



## 9.5习题

1. 下列关于Time-wait状态的说法错误的是？

   a.Time-wait状态只在服务器端的套接字中发生。

   **b.断开连接的四次挥手过程中，先传递FIN消息的套接字进入Time-wait状态**

   c.Time-wait状态与断开连接的过程无关，而与请求连接过程中SYN消息的传输顺序有关。

   d.Time-wait状态通常并非必要，应尽可能通过更改套接字可选项防止其发生。

   > 答：加粗字体为正确答案。

2. TCP_NODELAY可选项与Nagle算法有关，可通过它禁用Nagle。请问何时应考虑禁用Nagle算法？结合收发数据的特性给出说明。

   > 答：考虑禁用Nagle算法的情况：对大文件数据进行传输的情况，因为即使使用Nagle算法，网络中的数据包总体还是一样，但使用Nagle算法还要等待ACK号的返回，降低了传输速度。
   >
   > 书中的解答：当网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快，比如说在传输大文件时。

------





# 第十章 多进程服务器端

## 10.1 进程概念及应用

利用之前学习到的内容，我们可以构建按序向第一个客户端到第一百个客户端提供的服务器端。当然，第一个客户端不会抱怨服务器端，但如果每个客户端的平均服务时间为0.5秒，则第100个客户端会对服务器端产生相当大的不满。接下来讨论如何提高客户端满意度平均标准。

### 10.1.1 并发服务器端的实现办法

同时向所有发起请求的客户端提供服务，以提高平均满意度。网络程序中数据通信时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务器端实现模型和方法。

- 多进程服务器：通过创建多个进程提供服务。
- 多路复用服务器：通过捆绑并统一管理I/O对象提供服务。
- 多线程服务器：通过生成与客户端等量的线程提供服务。

先介绍第一种方法：多进程服务器。



### 10.1.2理解进程（Process）

进程的定义如下：

> 占用内存空间的正在运行的程序

假如你下载了一个游戏到电脑上，此时的游戏不是进程，而是程序。只有当游戏被加载到主内存并进入运行状态，这时才可称为进程。

| CPU的个数与进程数                                            |
| ------------------------------------------------------------ |
| 拥有2个运算设备的CPU称作（Daul）CPU，拥有4个运算器的CPU称作4核（Quad）CPU。也就说，1个CPU中可能包含多个运算设备（核）。核的个数与可同时运行的进程数相同。相反，若进程数超过核数，进程将分时使用CPU资源。但因为CPU运转速度极快，我们会感到所有进程同时运行。当然，核数越多，这种感觉越明显。 |



### 10.1.3 进程ID

讲解创建进程方法前，先简要说明进程ID。无论进程是如何创建的，所有进程都从操作系统分配到ID。此ID称为“进程ID”，其值大于2的整数。1要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户进程无法得到ID值1。接下来观察Linux中正在运行的进程。

- 运行结果：ps命令语句

  <img src="image\10.1.3.png" alt="1" style="zoom:50%;margin:0px;" />

  可以看出，通过ps指令可以查看当前运行的所有进程。特别需要注意的是，该命令同时列出PID（进程ID）。另外，上述示例通过指定a和u参数列出了所有进程详细信息。



### 10.1.4 通过调用fork函数创建进程

创建进程的方法很多，此处只介绍用于创建多进程服务器端的fork函数。

```c
#include<unistd.h>
pid_t fork(void);
```

> 成功时返回进程ID，失败时返回-1。

fork函数将创建调用的进程副本（概念上略难）。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程。另外，两个进程都将执行fork函数调用后的语句（准确地说是在fork函数返回后）。但因为通过同一进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。即利用fork函数的如下特点区分程序执行流程。

- 父进程：fork函数返回子进程ID。
- 子进程：fork函数返回0。

此处“父进程”（Parent Process）指原进程，即调用fork函数的主体，而“子进程”（Child Process）是通过父进程调用fork函数复制出的进程。接下来讲解调用fork函数后的程序运行流程，如下图所示：

<img src="image\10.1.4.png" alt="1" style="zoom:60%;margin:0px;" />

从上图可以看到，父进程调用fork函数的同时复制出子进程，并分别得到fork函数的返回值。但复制前，父进程将全局变量gval增加到11，将局部变量lval的值增加到25，因此在这种状态下完成进程复制。复制完成后根据fork函数的返回类型区分父子进程。父进程将lval的值加1，但这不会影响子进程的lval值。同样，子进程将gval的值加1也不会影响到父进程的gval。因为fork函数调用后分成了完全不同的进程，只是二者共享统一代码而已。接下来给出示例验证之前的内容。

- 代码参见：[fork.c](SK10/fork.c) 
- 运行结果：

```
Parent Proc: [9, 23]
Child Proc: [13, 27]
```

从运行结果可以看出，调用fork函数后，父子进程拥有完全独立的内存结构。对于父进程来说，fork函数返回的是子进程的ID，对于子进程来说，fork函数返回0。所以这两个变量，父进程进行了+2操作，而子进程进行了-2操作。





## 10.2 进程和僵尸进程

文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建也同等重要。如果未认真对待进程销毁，他们将变成僵尸进程。

### 10.2.1 僵尸（Zombie）进程

进程的工作完成后（执行完main函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中重要资源。这种状态下的进程称作「僵尸进程」，这也是给系统带来负担的原因之一。

> 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出，子进程被init接管，子进程退出后init会回收其占用的相关资源。

### 10.2.2 产生僵尸进程的原因

为了防止僵尸进程的产生，先解释产生僵尸进程的原因。利用如此两个示例展示调用fork函数产生子进程的终止方式。

- 传递参数并调用exit函数。
- main函数中执行return语句并返回值。

向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。也就是说，将子进程变成僵尸进程的正是操作系统。既然如此，此僵尸进程何时被销毁呢？其实已经给出提示：

> “应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值。”

如何向父进程传递这些值呢？操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要负责回收自己生的孩子（也许这种描述有些不妥）。接下来示例将创建僵尸进程。

- 代码参见：[zombie.c](SK10/zombie.c)

- 运行结果：

  ```
  Child Process ID: 57412
  Hi, I am a child process
  End child process
  ```

  程序开始运行后，将在如上所示状态暂停。跳出这种状态前（30秒内），应验证子进程是否为僵尸进程。该验证在其他控制窗口进行。

  

- 运行结果：僵尸进程的验证

  ```
  root       57297  0.0  0.2  10760  4944 pts/1    Ss   20:35   0:00 -bash
  root       57401  0.0  0.2  10760  4808 pts/0    Ss   21:22   0:00 -bash
  root       57411  0.0  0.0   2488   584 pts/1    S+   21:22   0:00 ./zombie
  root       57412  0.0  0.0      0     0 pts/1    Z+   21:22   0:00 [zombie] <defunct>
  root       57413  0.0  0.1  11492  3192 pts/0    R+   21:22   0:00 ps au
  ```

  可以看出，PID为57412的进程状态为僵尸进程（Z+）。另外，经过30秒的等待时间后，PID为57411的父进程和之前的僵尸子进程同时销毁。



### 10.2.3 销毁僵尸进程1：利用wait函数

为了销毁子进程，父进程应主动请求获取子进程的返回值。接下来讨论发起请求的2种具体方法，其中之一：

**`wait()`函数：**

```c
#include<sys/wait.h>
pid_t wait(int * statloc);
```

> 成功时返回终止的子进程ID，失败时返回-1。

调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指向内存空间。当函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。

- `WIFEXITED`子进程正常终止时返回“真”（true）。
- `WEXITSTATUS`返回子进程的返回值。

也就是说，向wait函数传递变量status的地址时，调用wait函数应编写如下代码。

```c
if(WIFEXITED(status)) //是正常终止的吗？
{
	puts("Normal termination!");
	printf("Child pass num: %d", WEXITSTATUS(status)); //那么返回值是多少?
}
```

根据上述内容编写示例，下面示例中不会再让子进程变成僵尸进程：

- 代码参见：[wait.c](SK10/wait.c)

- 运行结果

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK10#./wait &
  Child PID: 58459 
  Child PID: 58460 
  Chiled send one: 7 
  Child send two: 3 
  ps au
  ```

  系统中并无上述结果中的PID对应进程，下面进行验证：

  通过`ps au`命令查看进程信息：

  ```
  root       58458  0.0  0.0   2488   528 pts/0    S    10:28   0:00 ./wait
  root       58461  0.0  0.1  11492  3328 pts/0    R+   10:28   0:00 ps au
  ```

  可见除了父进程（30s后销毁），子进程都销毁了。这是因为调用了wait函数完全销毁了该进程。另外，2个子进程终止时返回的3和7传递到了父进程。

  

  这就是通过wait函数消灭僵尸进程的方法。调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此需谨慎调用该函数。

  

### 10.2.4 销毁僵尸进程2：使用waitpid函数

wait函数会引起程序阻塞，还可以考虑调用用waitpid函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。

**`waitpid()`函数：**

```c
#include<sys/wait.h>
pid_t waitpid(pid_t pid, int * statloc, int options);
```

> 成功时返回终止的子进程ID（或0），失败时返回-1。
>
> 参数1：`pid`，等待终止的目标子进程的ID，若传递-1，则与wait函数相同，可以等待任意子进程终止。
>
> 参数2：`statloc`，与wait函数的`statloc`参数具有相同含义。
>
> 参数3：`options`，传递头文件`sys/wait.h`声明的常量`WNOHANG`，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数。(记忆：WNOHANG ，w no hang 不悬挂，即不进入阻塞状态)

调用waitpid函数时，程序不会阻塞。下面介绍调用waitpid函数的示例：

- 代码参见：[waitpid.c](SK10/waitpid.c)

- 运行结果：

  ```
  root@iZwz9abtr8fgz78nfnbgjiZ:~/SK10# ./waitpid &
  [1] 58493
  sleep 3sec.
  sleep 3sec.
  sleep 3sec.
  sleep 3sec.
  sleep 3sec.
  Child send 24 
  ```

  可以看出waitpid函数共执行了5次，证明了waitpid函数非阻塞。





## 10.3 信号处理

我们已经知道了进程创建以及销毁方法，但还有一个问题没解决。

> “子进程究竟何时终止?调用waitpid函数后要无休止地等待吗？”

父进程往往与子进程一样繁忙，因此不能只调用waitpid函数以等待子进程终止。接下来讨论解决方案。

### 10.3.1向操作系统求助

子进程终止的识别主体是操作系统，因此，若操作系统能把如下信息告诉正忙于工作的父进程，将有助于构建高效的程序。

> “嘿，父进程！你创建的子进程终止了！”

此时父进程将暂时放下工作，处理子进程终止相关事宜。处理子进程需要引入信号处理（Singal Handling）机制。此处的“信号”是在特定事件发生使由操作系统向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程称为“处理”或“信号处理”。



### 10.3.2 信号与signal函数

下列进程和操作系统间的对话是帮助大家理解信号处理而编写的，其中包含了所有信号处理的相关内容。

> 进程：“嘿，操作系统！如果我之前创建的子进程终止，就帮我调用zombie_handler函数。”
>
> 操作系统：“好的！如果你的子进程终止，我会帮你调用zombie_handler函数，你先把该函数要执行的语句写好！”

上述对话相当于“注册信号”过程，即进程发现自己的子进程结束时，请求操作系统调用特定函数。（上述的对话就是对回调函数的使用）

请求操作系统调用特定函数会通过如下函数调用完成（因此称此函数为信号注册函数）（回调函数概念中的中间函数）。

**`signal()`函数：**

```c
#include<signal.h>
void (*signal(int signo, void(*func)(int)))(int);
```

> 上述signal函数的返回值类型为函数指针。
>
> 函数名：signal
>
> 参数：int signo, void(* func)(int)
>
> 返回类型：参数为int型，返回void型函数指针 `void (*signal)`。

调用上述signal函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。

下面给出可以在signal函数中注册的部分特殊情况和对应的常数。

> | 第一参数（特殊情况信息） | 对应常数说明                     |
> | :----------------------: | -------------------------------- |
> |        `SIGALRM`         | 已到通过调用alarm函数注册的时间  |
> |         `SIGINT`         | 输入<kbd>CTRL</kbd>+<kbd>C</kbd> |
> |        `SIGCHLD`         | 子进程终止                       |



接下来编写调用signal函数的语句，完成如下请求：

> “子进程终止则调用mychild函数。”

此时mychild函数的参数应为int，返回值类型应为void。只有这样才能匹配为signal函数的第二个参数。另外，常数SIGCHILD定义了子进程终止的情况，应成为signal函数的第一个参数。也就是说，signal函数调用语句如下。

```c
signal(SIGCHLD, mychild);
```



接下来编写signal函数的调用语句，分别完成如下2个请求。

> “已到通过alarm函数注册的时间，请调用timeout函数。”
>
> “输入<kbd>CTRL</kbd>+<kbd>C</kbd>调用keycontrol函数。”

代表这2种情况的常数分别为SIGALRM和SIGINT，因此按如下方式调用signal函数。

```c
signal(SIGALRM, timeout);
signal(SIGINT, keycontrol);
```

以上就是信号注册过程。

关于signal函数，可参考：https://www.cnblogs.com/liulipeng/p/3470753.html



注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。下面通过示例验证，先介绍alarm函数。

**`alarm()`函数**：alarm开启定时器，时间到后给调用alarm的进程发送一个SIGALRM信号。

```c
#include<unistd.h>
unsigned int alarm(unsigned int seconds);
```

> 返回0或以秒单位的距SIGALRM信号发生所剩时间。

如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生SIGALRM信号。若向该函数传递0，则之前对SIGALRM信号的预约将取消。如果通过该函数预约信号后未指定该信号对应的处理函数，则（通过调用signal函数）终止进程，不做任何处理。希望引起注意。

接下来给出信号处理相关示例：

- 代码参见：[signal.c](SK10/signal.c)

- 运行结果：

  ```
  wait...
  Time out!
  wait...
  Time out!
  wait...
  Time out!
  ```

  为了查看信号产生和信号处理器的执行提供每次100秒、共3次的等待时间，在循环中调用sleep函数。也就是说，再过300秒后终止程序。但实际执行时只需不到10秒。为什么？

  **原因：**SIGALRM处理器中调用了alarm函数，当预约2s后发生SIGALRM信号，向调用alarm函数的SIGALRM处理器（也就是timeout()）发送一个SIGALRM信号，将唤醒由于调用sleep函数而进入阻塞状态的进程。进程一旦被唤醒就不会在进入睡眠状态，所以for语句中未到sleep函数中规定的时间就执行下一次循环。

  

  在短短的10s的运行过程中输入<kbd>CTRL</kbd>+<kbd>C</kbd>，可以看到输出`CTRL+C pressed`字符串。



### 10.3.3 利用sigaction函数进行信号处理

前面所学的内容足以用来编写防止僵尸进程生成的代码。但我还想介绍sigaction函数，它类似于signal函数，而且完全可以替代后者，也更稳定。之所以稳定，是因为如下原因：

> “signal函数在UNIX系列的不同操作系统中可能存在区别，但sigaction函数完全相同。”

实际上现在很少使用signal函数编写程序，他只是为了保持对旧程序的兼容。下面介绍sigaction函数，但只讲解可替换signal函数的功能，因为全面介绍会给各位带来不必要的负担。

**`sigaction()`函数**

```c
#include<signal.h>
int sigaction(int signo, const struct sigacion * act, struct sigacion * oldact);
```

> 成功时返回0，失败时返回-1。
>
> 参数1：signo，与signal函数相同，传递信号信息。
>
> 参数2：act，对应于第一个参数的信号处理函数（信号处理器）信息。
>
> 参数3：oldact，通过此参数获取之前注册的信号处理函数指针，若不需要则传递0。

声明并初始化sigaction结构体变量以调用上述函数，该结构体定义如下：

```c
struct sigaction
{
	void(*sa_handler)(int);
	sigset_t sa_mask;
	int sa_flags;
}
```

此结构体的sa_handler成员保存信号处理函数的指针值（地址值）。sa_mask和sa_flags的所有位均初始化为0即可。这2个成员用于指定信号相关的选项和特性，而我们的目的主要是防止产生僵尸进程，故省略。

下面给出代码示例，其中包括了尚未讲解得到使用sigaction函数所需全部内容。

- 代码参见：[sigaction.c](SK10/sigaction.c)

- 运行结果：

  ```
  wait...
  Time out!
  wait...
  Time out!
  wait...
  Time out!
  ```

这就是信号处理相关理论，以此为基础讨论消灭僵尸进程的方法。



### 10.3.4 利用信号技术消灭僵尸进程

下面代码示例中利用sigaction函数来销毁僵尸进程，子进程终止时将产生SIGCHLD信号

- 代码参见：[remove_zombie.c](SK10/remove_zombie.c)

- 运行结果：

  ```
  Child proc id: 60884 
  Child proc id: 60885 
  wait...
  Hi! I'm child process
  Hi! I'm child process
  wait...
  wait...
  Removed proc id: 60885 
  Child send: 24 
  wait...
  Removed proc id: 60884 
  Child send: 12 
  wait...
  ```

  可以看出，子进程并未变成僵尸进程，而是正常终止了。接下来利用进程相关知识编写服务器端。



## 10.4 基于多任务的并发服务器

我们已做好了利用fork函数编写并发服务器的准备，现在可以开始编写像样的服务器端了。

### 10.4.1 基于进程的并发服务器模型

之前的回声服务器端每次只能向1个客户端提供服务。因此，我们将扩展回声服务器端，使其可以同时向多个客户端提供服务。下图给出了基于多进程的并发回声服务器端的实现模型。

<img src="image\10.4.1.png" style="zoom:60%;margin:0px;" />

从上图可以看出，每当有客户端请求服务（请求连接）时，回声服务器端都创建子进程以提供服务。请求服务的客户端若有5个，则将创建5个子进程提供服务。为了完成这些任务，需要经过如下过程，这是与之前的回声服务器端的区别所在。

- 第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求。
- 第二阶段：此时获取的套接字文件描述符创建并传递给子进程。
- 第三阶段：子进程利用传递来的文件描述提供服务。

此处容易引起困惑的是向子进程传递套接字文件描述符的方法。但各位读完代码后会发现 ，这其实没什么大不了的，因为子进程会复制父进程拥有的所有资源。实际上根本不用另外经过传递文件描述符的过程。



### 10.4.2 实现并发服务器

下面给出并发服务器端的实现代码：

代码参见：[echo_mpserv.c](SK10/echo_mpserv.c)

启动服务器后，创建多个客户端并建立连接，可以验证服务器端同时向大多数客户端提供服务。



### 10.4.3 通过fork函数复制文件描述符

上述示例中给出了通过fork函数复制文件描述符的过程。父进程将2个套接字（一个是服务端套接字另一个是客户端套接字）文件描述符复制给了子进程。

调用fork函数时复制父进程的所有资源，但是套接字不是归进程所有的，而是归操作系统所有，只是进程拥有代表相应套接字的文件描述符。

<img src="image\10.4.3.png" style="zoom:55%;margin:0px;" />

上图中，1个套接字存在2个文件描述符时，只有2个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法销毁套接字（服务器套接字同样如此）。因此调用fork函数后，要将无关紧要的套接字文件描述符关掉，如下图所示:

<img src="image\10.4.3_2.png" alt="1" style="zoom:51%;margin:0px;" />

为了将文件描述符整理成图10-4的形式，示例echo_myserv.c的第60行和第69行调用了close函数。



## 10.5 分割TCP的I/O程序

### 10.5.1 分割I/O程序的优点

我们已实现的回声客户端的数据回声方式如下：

> “向服务器端传输数据，并等待服务器端回复。无条件等待，直到接受完服务器端的回声数据后，才能传输下一批数据。”

传输数据后需要等待服务器端返回的数据，因为程序代码中重复调用了read和write函数。只能这么写的原因之一是，程序在1个进程中运行。但现在可以创建多个进程，因此可以分割数据收发过程。默认的分割模型如图10-5所示。

从图10-5可以看出，客户端的父进程负责接收数据，额外创建的子进程负责发送数据。分割后，不同进程分别负责输入和输出，这样，无论客户端是否从服务器端接受完数据都可以进行传输。

<img src="image\10.5.1.png" style="zoom:55%;margin:0px;" />

选择这种实现方式的原有有很多，但最重要的一点是，程序的实现更加简单。也许有人质疑：既然多产生1个进程，怎么能简化程序实现呢？其实，按照这种方式，父进程中只需编写接收数据的代码，子进程中只需编写发送数据的代码，所以会简化。实际上，在1个进程内同时实现数据收发逻辑需要考虑更多细节。程序越复杂，这种区别越明显，它也是公认的优点。

提示：回声客户端不用分割I/O程序。



分割I/O程序的另一个好处是，可以提高频繁交换数据的程序性能，如下图所示：

<img src="image\10.5.1 (2).png" style="zoom:60%;margin:0px;" />

上图左侧演示的是之前的回声客户端数据交换方式，右侧演示的是分割I/O后的客户端数据传输方式。服务器端相同，不同的是客户端区域。分割I/O后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，因此提高同一时间内容传输的数据量。这种差异在网速较慢的时尤为明显。



### 10.5.2 回声客户端的I/O程序分割

我们已经知道I/O程序分割的意义，接下来通过实际代码进行实现，分割的对象是回声客户端。下列回声客户端可以结合之前的回声服务器端[echo_mpserv.c](SK10/echo_mpserv.c)运行。

- 代码参见：[echo_mpclient.c](SK10/echo_mpclient.c)
- 运行结果跟普通回声服务器端/客户端相同，故省略。



## 10.6 习题

以下答案仅代表个人观点，可能不是正确答案。

1. 下列关于进程的说法错误的是？

   **a.从操作系统的角度上说，进程是程序运行的单位。**

   **b.进程根据创建方式建立父子关系。**

   c.进程可以包含其他进程，即一个进程的内存空间可以包含其他进程。

   **d.子进程可以创建其他子进程，而创建出来的子进程还可以创建其子进程。**

   > 答：加粗字体为正确答案。
   >
   > c：不可以包含，父进程和子进程是独立的内存空间上的。

2. 调用fork函数将创建子进程，以下关于子进程的描述错误的是？

   **a.父进程销毁时也会同时销毁子进程。**

   **b.子进程是复制父进程所有资源创建出的进程。**

   c.父子进程共享全局变量。

   d.通过fork函数创建的子进程将执行从开始到fork函数调用为止的代码。

   > 答：加粗字体为正确答案。

3. 创建子进程时将复制父进程的所有内容，此时的复制对象也包含套接字文件描述符。编写程序验证复制的文件描述符整数值是否与源文件描述符整数值相同。

   > 答：程序代码：[my_test3.c](SK10/my_test3.c)
   >
   > 运行结果：
   >
   > ```
   > parent's sock's val: 3 
   > child's sock's val: 3 
   > ```
   >
   > 结果说明，通过fork()函数，子进程的套接字描述符和父进程的一样，套接字整数值都为3。

   

4. 请说明进程变为僵尸进程的过程及预防措施。

   > 答：当子进程在父进程结束之前执行完毕，子进程将会占用系统资源直到父进程结束，该子进程此时变为僵尸进程。预防措施：①当子进程执行退出语句return 或 exit(1)后，可以调用wait()函数或调用waitpid()函数销毁僵尸进程；②通过alarm函数预约的时间唤醒进程，将SIGALRM信号发送给调用了alarm函数的信号处理器，signal信号注册函数会根据指定的信号处理器进行waitpid()操作，从而销毁僵尸进程；③当子进程执行退出后，sigaction（signal()也可以）中的SIGCHLD参数会指明当有子进程结束时，可以调用该信号对应的信号处理器来执行waitpid()，从而销毁僵尸进程。

   

5. 如果在未注册SIGINT信号的情况下输入Ctrl+C，将由操作系统默认的事件处理器终止程序。但如果直接注册Ctrl+C信号的处理器，则程序不会终止，而是调用程序员指定的事件处理器。编写注册处理函数程序，完成如下功能：

   “输入Ctrl+C时，询问是否确定退出程序，输入Y则终止程序。”

   另外，编写程序使其每隔1秒输出简单字符串，并适用于上述时间处理器注册代码。

   > 答：程序代码：[my_test5.c](SK10/my_test5.c)
   >
   > 运行结果：
   >
   > ```
   > I do love C++!
   > I do love C++!
   > ^C
   > quit y/n?
   > y
   > ```

   ------



# 第十一章 进程间通信

------

第十章讲解了如何创建进程，本章将讨论创建的2个进程之间交换数据的方法。这与构建服务器端并无直接关系，但有助于构建多种类型服务器端，以及更好地理解操作系统。

## 11.1 进程间通信的基本概念

进程间通信（Inter Process Communication）意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应提供两个进程可以同时访问的内容空间。

### 11.1.1 对进程间通信的基本理解

进程A和B之间的如下对话就是一种进程间通信息规则：

> “如果我有1个面包，变量bread的值变为1。如果吃掉这个面包，bread的值又变回0。因此，你可以通过变量bread值判断我的状况。”

也就是说，进程A通过变量bread将自己的状态通知给了进程B，进程B通过变量bread听到了进程A的话。因此，只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据。但正如第10章所讲，进程具有完全独立的内存结构。就连通过fork函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方式完成。

上面介绍了进程间通信的含义及其无法简单实现的原因，下面正式介绍进程间通信方法。

### 11.1.2 通过管道实现进程间通信

下图表示基于管道（PIPE）的进程间通信结构模型

<img src="image\11.1.2.png" style="zoom:30%;margin:0px;" />

从上图可以看到，为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是fork函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。

- 创建管道的函数

  ```c
  #include<unistd.h>
  int pipe(int filedes[2]);
  ```

  > 成功时返回0，失败时返回-1。
  >
  > `filedes[0]`，通过管道接收数据时使用的文件描述符，即管道出口。
  >
  > `filedes[1]`，通过管道传输数据时使用的文件描述符，及管道入口。
  >
  > 0,1 ,分别为管道出口，管道入口，记忆：**出入**

  以长度为2的int数组地址值作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的1个文件描述符传递给子进程。如何完成传递呢？答案就是调用fork函数。

- 代码示例：[pipe1.c](SK11/pipe1.c)

  ```c
  #include<stdio.h>
  #include<unistd.h>
  #define BUF_SIZE 30
  
  int main(int argc, char * argv[])
  {
  	int fds[2];
  	char str[] = "Who are you?";
  	char buf[BUF_SIZE];
  	pid_t pid;
  	
  	pipe(fds);
  	pid = fork();
  	if(pid == 0)
  	{
  		write(fds[1], str, sizeof(str));
  	}
  	else
  	{
  		read(fds[0], buf, BUF_SIZE);
  		puts(buf);
  	}
  	return 0;
  }
  ```

- 运行结果：

  ```
  Who are you?
  ```

  输出内容为：父进程从管道中读取的数据

  

上述示例中的通信方法及路径如下图所示。重点在于，父子进程都可以访问管道的I/O路径，但子进程仅用于输入路径，父进程仅用于输出路径。

<img src="image\11.1.2_2.png" alt="1" style="zoom:35%;margin:0px;" />

以上就是管道的基本原理及通信方法。应用管道时还有一部分内容需要注意，通过双向通信示例进一步说明。



### 11.1.3 通过管道进行进程间双向通信

下面创建2个进程通过1个管道进行双向数据交换的示例，其通信方式如下图所示：

<img src="image\11.1.3.png" alt="1" style="zoom:50%;margin:0px" />

上图可以看出，通过1个管道进行双向通信。但采用这种模型使需格外注意。先给出代码示例，稍后再讨论。

- 代码示例：[pipe2.c](SK11/pipe2.c)

- 运行结果：

  ```
  Parent proc output: Who are you? 
  Child proc output: Thank you for you message
  ```

  

  之后注释掉第18行代码后再运行（务必亲自动手操作）。

  注释掉后运行：

  ```
  Child proc output: Who are you? 
  无限期等待....
  ```

  虽然这行代码只将运行时间延迟了2秒，但已引发运行错误。产生原因是什么呢？

  > “向管道传递数据时，先读的进程会先把数据取走。”

  简言之，数据进入管道后将成为无主数据。也就是通过read函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。结果，父进程调用read函数后将无限期等待数据进入管道。



从上述示例中可以看到，只用1个管道进行双向通信并非易事。为了实现这一点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。既然如此，该如何进行双向通信呢？

> “创建2个管道。”

非常简单，1个管道无法完成双向通信任务，因此需要创建2个管道，各自负责不同的数据流即可。其过程下图所示。

<img src="image\11.1.3_2.png" style="zoom:40%;margin:0px;" />

由上图可知，使用2个管道可以避免程序流程的预测或控制。下面采用上述模型改进pipe2.c。

改进后的程序代码：

- 代码参见：[pipe3.c](SK11/pipe3.c)

  > 上面通过创建两个管道实现了功能，此时，不需要额外再使用sleep函数。

- 运行结果：

  ```
  Parent proc output: Who are you? 
  Child proc output: Thank you for your message 
  ```

  >运行结果和pipe1.c一样。



## 11.2 运用进程间通信

上一节学习了基于管道的进程间通信方法，接下来将其运用到网络代码中。如前所述，进程间通信与创建服务器端并没有直接关联，但其有助于理解操作系统。

### 11.2.1 保存消息的回声服务器端

下面扩展第10章的echo_mpserv.c，添加如下功能：

> “将回声客户端传输的字符串按序保存到文件中。”

我希望将该任务委托给另外的进程。换言之，另行创建进程，从向客户端提供服务的进程读取字符串信息。当然，该过程中需要创建用于接收数据的管道。

下面给出示例。该示例可以与任意回声客户端配合运行，但我们将用第10章介绍过的echo_mpclient.c。

- 代码参见：[echo_storeserv.c](SK11/echo_storeserv.c)

- 服务器端运行结果：

  ```
  new client connected...
  new client connected...
  remove proc id: 68313 
  client disconnected...
  remove proc id: 68316 
  client disconnected...
  remove proc id: 68319 
  ```

- 客户端1运行结果：

  ```
  one
  Message from server: one
  three
  Message from server: three
  fine
  Message from server: fine
  seven
  Message from server: seven
  nine
  Message from server: nine
  ```

- 客户端2运行结果

  ```
  two
  Message from server: two
  four
  Message from server: four
  six
  Message from server: six
  eight
  Message from server: eight
  ten
  Message from server: ten
  ```

如上运行结果所示，文件中累计一定数量字符串后（共10次的fwrite函数调用完成后），可以打开echomsg.txt验证保存的字符串。

- echomsg.txt 内容如下

  ```
  one
  two
  three
  four
  fine
  six
  seven
  eight
  nine
  ten
  ```



上述程序中，与客户端进行数据交换的服务器子进程，在进行本地文件保存过程中所传递的数据都是共用同一个pipe，详细可参考知乎中的一个回答：

<img src="image\11.3.png" style="zoom:85%;margin:0px;" />



图解[echo_storeserv.c](SK11/echo_storeserv.c) 程序：<img src="image\11.2.1_2.png" style="zoom:50%;" />



这里有我一个个人的思考：

> 当上图11.2.1中③处fork函数比accept提前一步被调用，那么就会有如下的问题：是父进程还是子进程对客户端连接请求进行受理？
>
> 可以参考知乎中的提问回答：[一个进程绑定了端口号后，创建子进程（fork），子进程是不是和父进程绑定了同一个端口号？](https://www.zhihu.com/question/360939266)
>
> <img src="image\11.2.1_3.png" alt="1" style="zoom:100%;margin:0px;" />





## 11.3 习题

1. 什么是进程间通信？分别从概念上和内存的角度进行说明。

   > 答：概念上，进程间通信指的是两个进程之间的数据交换过程。以内存的角度来说，每个进程都有独立的内存空间，进程间的通信需要操作系统提供的管道来进行进程间的数据交换。

2. 进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？

   > 答：进程拥有独立的内存资源，除了操作系统提供的管道通信等，进程无法依靠自身的资源与其他进程进行数据交换。

3. “管道”是典型的IPC技法。关于管道，请回答如下问题。

   a.管道是进程间交换数据的路径。如何创建此路径？由谁创建？

   > 答：使用pipe函数进行创建，由操作系统创建。父进程调用该函数时将创建管道。
   
   b.为了完成进程间通信，2个进程需同时连接管道。那2个进程如何连接到同一管道？
   
   > 答：使用相同名的管道文件描述符，可以通过父进程调用fork函数生成子进程，子进程将会拥有父进程的所有资源包括管道文件描述符，具备相同的管道文件描述符，这两个进程间可以连接到同一管道。
   
   c.管道允许进行2个进程间的双向通信。双向通信中需要注意哪些内容？
   
   > 答：管道是无名管道，也就是某一进程向管道中写入数据，之后无论哪一个进程包括刚刚写入数据的进程都可以从管道中读取数据。对同一个进程进行双向通信，需要调整两个进程的收发顺序来避免自己发自己读的错误。
   >
   > 附上参考回答：向管道传输数据时，先读的进程会把数据取走。简言之，就是数据进入管道后会变成无主数据，所以有时候为了防止错误，需要多个管道来进行进程通信。
   
4. 编写示例复习IPC技法，使2个进程相互交换3次字符串。当然，这2个进程应具有父子关系，各位可指定任意字符串。

   > 答：
   >
   > - 代码实现：[my_test4.c](SK11/my_test4.c)
   >
   > - 运行结果：
   >
   >   ```
   >   I do love C++!
   >   I will learn hard!
   >   I do love C++!
   >   I will learn hard!
   >   I do love C++!
   >   I will learn hard!
   >   ```

------





# 第十二章 I/O复用

------

本章将讨论并发服务器的第二种实现方法，基于I/O复用（Multi-plexing）的服务器端构建。

## 12.1 基于I/O复用的服务器端

### 12.1.1 多进程服务器端的缺点和解决方法

为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中常用的一种方案，但并非十全十美，因为创建进程时需要付出极大代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法（IPC属于相对复杂的通信方法）。

> “那有何解决方法？能否在不创建进程的同时向多个客户端提供服务？”

当然能！本节讲解的I/O复用就是这种技术。大家听到这种方法是否感到一阵兴奋？但请不要过于依赖该模型！该方案不适用于所有情况，应当根据目标服务器端的特点采用不同实现方法。下面先理解“复用（Multiplexing）”的意义。

### 12.1.2 理解复用

“复用”在电子及通信工程领域很常见，向这些领域的专家询问其概念时，他们会亲切地进行如下说明：

> “在1个通信频道中传递多个数据（信号）技术。”

再看看“复用”的含义：

> “为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。”

<img src="image\12.1.2.png" style="zoom:40%;margin:0px;" />

上图12-1时远距离的3人可以同时通话的3方对话纸杯电话系统。为了使3人同时对话，需准备图中所示系统。另外，为了完成3人对话，说话时需同时对着两个纸杯，接听时也需要耳朵同时对准两个纸杯。此时引入复用技术会使通话更加方便，如下图12-2所示。

<img src="image\12.1.2_2.png" style="zoom:40%;margin:0px;" />

复用技术的优点：

- 减少连接长度。
- 减少纸杯个数

即使减少了连线和纸杯的量仍能进行3人通话，当然也有人在考虑如下这种情况：

> “好像不能同时说话？”

实际上，因为是在进行通话，所以很少发生同时说话的情况。也就是说，上述系统采用的是「时分复用技术」。而且，因为说话人声高（频率）不同，即使同时说话也能进行一定程度的区分（当然杂音也随之增多）。因此，也可以说系统同时采用了「频分复用技术」（频：frequency）。



### 12.1.3 复用技术在服务器端的应用

纸杯电话系统引入复用技术后，可以减少纸杯数和连线长度。同样，服务器端引入复用技术可以减少所需进程数。为便于比较，先给出第十章的多进程服务器端模型，如下图所示：

<img src="image\12.1.3.png" style="zoom:55%;margin:0px;" />

下图的模型中引入复用技术，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有1个。

<img src="image\12.1.3_2.png" style="zoom:60%;margin:0px;" />

以上就是I/O复用服务器端模型的介绍。

<img src="image\12.1.3_3.png" style="zoom:70%;" />





## 12.2 理解select函数并实现服务器端

运用select函数是最具代表性的实现复用服务器端方法。Windows平台下也有同名函数提供相同功能，因此具有良好的移植性。

### 12.2.1 select函数的功能和调用顺序

使用select函数时可以将多个文件描述符集中到一起统一监视，项目如下：

- 是否存在套接字接收数据？
- 无需阻塞传输数据的套接字有哪些?
- 哪些套接字发生了异常？

| 监视项称为「事件」（event）                                  |
| ------------------------------------------------------------ |
| 上述监视项称为“事件”。发生监视项对应情况时，称“发生了事件”。这是最常见的表达。 |

select函数的使用方法与一般函数区别较大，更准确地说，它很难使用。但为了实现I/O复用服务器端，我们应掌握select函数，并运用到套接字编程中。认为「select函数是I/O复用的全部内容」也并不为过。接下来介绍select函数的调用方法和顺序，如下图所示。

<img src="image\12.2.1.png" style="zoom:50%;margin:0px;" />

上图给出了调用select函数到获取结果所经过程。可以看到，调用select函数前需要一些准备工作，调用后还需查看结果。接下来按照上述顺序逐一讲解。

### 12.2.2 设置文件描述符

利用select函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中到一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述3种监视项分成3类。

使用fd_set数组变量执行此项操作，如下图所示。该数组是存有0和1的位数组。

<img src="image\12.2.2.png" alt="1" style="zoom:50%;margin:0px;" />

上图最左端的位表示文件描述符0（所在位置）。如果该位设置为1，则表示该文件描述符是监视对象。那么图中哪些文件描述符是监视对象呢？很明显，是文件描述符1和3。

> “是否应当通过文件描述符的数字直接将值注册到fd_set变量？”

当然不是！针对fd_set变量的操作是以位为单位进行的，这也意味着直接操作该变量会比较繁琐。难道要求各位自己完成吗？实际上，在fd_set变量中注册或更改值的操作都由下列宏完成。

- `FD_ZERO(fd_set* fdset)`，将`fd_set`变量的所有位初始化位0。
- `FD_SET(int fd, fd_set * fdest)`，在参数`fd_set`指向的变量中注册文件描述符fd的信息
- `FD_CLR(int fd, fd_set * fdset)`，从参数`fd_set`指向的变量中清除文件描述符fd的信息。
- `FD_ISSET(int fd, fd_set * fdset)`，若参数`fd_set`指向的变量中包含文件描述符fd的信息，则返回“真”。

上述函数中，`FD_ISSET`用于验证select函数的调用结果。通过下图解释这些函数的功能，简洁易懂，无需赘述。

<img src="image\12.2.2_2.png" style="zoom:70%;margin:0px;" />



### 12.2.3 设置检查（监视）范围及超时

- **`select()函数：`**

  ```c
  #include<sys/select.h>
  #include<sys/time.h>
  int select(
  int maxfd, fd_set * readset, fd_set * writeset, fd_set * exceptset, const struct timeval * timeout);
  ```

  > 成功时返回大于0的值，失败时返回-1。
  >
  > 参数1：maxfd，监视对象文件描述符数量。
  >
  > 参数2：readset，将所有关注 “是否存在带读取数据” 的文件描述符注册到fd_set型变量，并传递其地址值。
  >
  > 参数3：writeset，将所有关注 “是否可传输无阻塞数据” 的文件描述符注册到fd_set型变量，并传递其地址值。
  >
  > 参数4：exceptset，将所有关注 “是否发生异常” 的文件描述符注册到fd_set型变量，并传递其地址值。
  >
  > 参数5：timeout，调用select函数后，为防止陷入无限阻塞的状态，传递超时（time-out）信息。
  >
  > 
  >
  > 返回值：发生错误时返回-1，超时返回时返回0。因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。

如上所述，select函数用来验证3种监视项的变化情况。根据监视项声明3个fd_set型变量，分别向其注册文件描述符信息，并把信息的地址值传递到上述函数的第二到第四个参数。但在此之前（调用select函数前）需要决定下面2件事。

> “文件描述符的监视（检查）范围是？”
>
> “如何设定select函数的超时时间？”

第一、文件描述符的监视范围与select函数的第一个参数有关。实际上，select函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在fd_set变量中的文件描述符数。但每次新建文件描述符，其值都会增1，故只需将最大的文件描述符值加1再传递到select函数即可。加1是因为文件描述符的值从0开始。

第二，select函数的超时时间与select函数的最后一个参数有关，其中timeval结构体定义如下：

```c
struct timeval
{
	long tv_sec;	//seconds
	long tv_usec;	//microseconds
}
```

本来select函数只有在监视的文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过声明上述结构体变量，将秒数填入`tv_sec`成员，将毫秒数填入`tv_usec`成员，然后将结构体的地址值传递到select函数的最后一个参数。此时，即使文件描述符中未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下，select函数返回0。因此，可以通过返回值了解返回原因。如果不想设置超时，则传递NULL参数。



### 12.2.4 调用select函数后查看结果

前面介绍了select函数，函数调用后查看结果也同样重要。如果返回大于0的整数，说明相应数量的文件描述符发生变化。

| 文件描述符的变化                                             |
| ------------------------------------------------------------ |
| 文件描述符变化是指监视的文件描述符中发生了相应的监视事件。例如，通过select的第二个参数传递的集合中存在需要读数据的描述符时，就意味着文件描述符发生变化。 |

select函数返回正整数时，怎样获知哪些文件描述符发生了变化?

向select函数的第二到第四个参数传递的fd_set变量中将产生如下图所示变化，获知过程并不难。

<img src="image\12.2.4.png" style="zoom:45%;margin:0px;" />

由上图可知，select函数调用完成后，向其传递的fd_set变量中将发生变化。原来为1的所有位均变为0，但发生变化的文件描述符对应位除外。因此，可以认为值仍为1的位置上的文件描述符发生了变化。



### 12.2.5 select函数调用实例

下面通过示例把select函数所有知识点进行整合。

- 代码参见：[select.c](SK12/select.c)

- 运行结果：

  ```
  hello
  message from console: hello
  hi
  message from console: hi
  Time-out!
  Good BYE!
  message from console: Good BYE!
  ```

  运行后若无任何输入，经5秒将发生超时。若通过键盘输入字符串，则可看到相同字符串输出。



### 12.2.6 实现I/O复用服务器端

下面通过select函数实现I/O复用服务器端。

- 代码参见：[echo_selectserv.c](SK12/echo_selectserv.c)

- 运行结果：echo_selectserv.c

  ```
  connected client: 4
  connected client: 5
  closed client: 5
  closed client: 4
  ```

- 运行结果：echo_client.c one

  ```
  Input message(Q to quit):i am client 1!
  Message from server: i am client 1!
  Input message(Q to quit):hello
  Message from server: hello
  Input message(Q to quit):q
  ```

- 运行结果：echo_client.c two

  ```
  Input message(Q to quit):i am client 2!
  Message from server: i am client 2!
  Input message(Q to quit):q
  ```

  为了验证运行结果，我使用了第四章介绍的echo_client.c。

  验证结果说明，虽然只有一个服务器端的进程，但是却实现了可以和多个客户端进行通信，这都是利用了select的特点。



## 12.4 习题

1. 请解释复用技术的通用含义，并说明何为I/O复用。

   > 答：复用含义：为了提高物理设备的效率，用最少的物理要素传递最多数据时采用的技术；
   >
   > I/O复用就是通过一个进程实现向多个客户端提供并发服务。
   
2. 多进程并发服务器的缺点有哪些？如何在I/O复用服务器端中弥补？

   > 答：多进程并发服务器是通过创建与客户端对应个数的子进程来提供服务，缺点在于每个进程有完全独立的内存空间，创建多进程将会占用大量的内存空间。I/O复用服务器只需一个服务器端进程，通过时分复用和频分复用技术来实现与多个客户端进行数据交换。其中利用select函数对注册在fd_set变量中的套接字文件描述符进行监视，当监视的套接字文件描述符发生变化时，操作系统会下到fd_set中进行遍历，执行变化的套接字相应的处理函数。

3. 复用服务器端需要select函数。下列关于select函数使用方法的描述错误的是?

   **a.调用select函数前需要集中I/O监视对象的文件描述符。**

   b.若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。

   c.复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

   **d.与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此，可以减少因创建进程产生的服务器端的负担。**

   > 答：加粗字体为正确答案。
   >
   > b.后续调用select函数需要重复初始化fd_set变量中的文件描述符信息，因为上一轮没有变化的文件描述符位设置为0，表示没有变化，如果没有重复初始化fd_set变量中的文件描述符信息，下一轮将无法监视上一轮没有变化的文件描述符。
   >
   > c.复用服务器端是属于并发服务器，不存在客户端等待的情况。

4. select函数的观察对象中应包含服务器端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。

   > 答：监听套接字是对客户端连接请求的接收，客户端连接请求本身也就是从网络中接收到的一种数据，所以监听套接字属于带读取数据的fd_set变量中。

   ------





# 第十三章 多种I/O函数

------

本章的Linux示例将使用send & recv 函数，并讲解其与read & write 函数相比的优点所在。还将介绍几种其他的I/O函数。

## 13.1 send & recv 函数

### 13.1.1 Linux中的send & recv

本节介绍Linux平台下的send & recv函数。其实二者并无差别。

- **`send()函数:`**

  ```c
  #include<sys/socket.h>
  ssize_t send(int sockfd, const void * buf, size_t nbytes, int flags);
  ```

  > 成功时返回发送的字节数，失败时返回-1。
  >
  > 参数1：sockfd，表示与数据传输对象的链接的套接字文件描述符。
  >
  > 参数2：buf，保存待传输数据的缓冲地址值。
  >
  > 参数3：nbytes，待传输的字节数。
  >
  > 参数4：flags，传输数据时指定的可选项信息。

- **`recv()函数：`**

  ```c
  #include<sys/socket.h>
  ssize_t recv(int sockfd, void * buf, size_t nbytes, int flags);
  ```

  > 成功时返回接收的字节数（收到EOF时返回0），失败时返回-1。
  >
  > 参数1：sockfd，表示数据接收对象的连接的套接字文件描述符。
  >
  > 参数2：buf，保存接收数据的缓冲地址值。
  >
  > 参数3：nbytes，可接收的最大字节数。
  >
  > 参数4：flags，接收数据时指定的可选项信息。

  

send函数和recv函数的最后一个参数是收发数据时的可选项。该可选项可利用「位或（bit OR）运算（|运算符）」同时传递多个信息。

通过下表整理可选项的种类及含义：

| 可选项（option） | 含义                                                         | send | recv |
| :--------------: | ------------------------------------------------------------ | :--: | :--: |
|     MSG_OOB      | 用于传输带外数据（Out-of-band data）                         |  O   |  O   |
|     MSG_PEEK     | 验证输入缓冲是否存在接收的数据                               |      |  O   |
|  MSG_DONTROUTE   | 数据传输过程中不参照路由（Routing）表，在本地（Local）网络中寻找目的地 |  O   |      |
|   MSG_DONTWAIT   | 调用I/O函数时不阻塞，用于使用非阻塞（Non_blocking）I/O       |  O   |  O   |
|   MSG_WAITALL    | 防止函数返回，直到接收全部请求的字节数                       |      |  O   |

另外，不同操作系统对上述可选项的支持也不同。因此，为了使用不同可选项，各位需要对实际开发中采用的操作系统有一定了解。



### 13.1.2 MSG_OOB：发送紧急消息

MSG_OOB可选项用于发送“带外数据”紧急消息。假设医院里有很多病人在等待看病，此时若有急诊患者该怎么办?

> “当然应该优先处理。”

如果急诊患者较多，需要得到等待看病的病人的谅解。正因如此，医院一般会设立单独的急诊室。需紧急处理时，应采用不同的处理方法和通道。MSG_OOB可选项就用于创建特殊发送方法和通道以发送紧急消息。

下列示例通过MSG_OOB可选项收发数据。使用MSG_OOB时需要一些拓展知识，这部分内容通过源代码进行讲解。

代码参见：

- [oop_send.c](SK13/oob_send.c)
- [oop_recv.c](SK13/oob_recv.c)

上述示例中插入了未曾讲解的函数调用语句，关于此函数之讲解必要部分。

```C
fcntl(recv_sock, F_SETOWN, getpid());
```

fcntl函数用于控制文件描述符，但上述调用语句的含义如下：

> “将文件描述符recv_sock指向的套接字拥有者（F_SETOWN）改为把getpid函数返回值用作ID的进程。”

各位或许感觉“套接字拥有者”的概念有些生疏。操作系统实际创建并管理套接字，所以从严格意义上说，“套接字拥有者”是操作系统。只是此处所谓的“拥有者”是指负责套接字所有事务的主体。上述描述可简要概括如下：

> “文件描述符recv_sock指向的套接字引发的SIGURG信号处理进程变为将getpid函数返回值用作ID的进程。”

当然，上述描述中的“处理SIGURG信号”指的是“调用SIGURG信号处理函数”。但之前讲过，多个进程可以共同拥有1个套接字的文件描述符。例如，通过调用fork函数创建子进程并同时复制文件描述符。此时如果发生SIGURG信号，应该调用哪个进程的信号处理函数呢？可以肯定的是，不会调用进程所有进程的信号处理函数（想想就知道这会引发更多问题）。因此，处理SIGURG信号时必须指定处理信号进程，而getpid函数返回调用此函数的进程ID。上述调用语句指定当前进程为处理SIGURG信号的主体。该程序中只创建了1个进程，因此，理应由该进程处理SIGURG信号。接下来先给出运行结果，再讨论剩下的问题。

<img src="image\13.1.2.png" style="zoom:90%;margin:0px;" />

输出结果可能出乎大家预料，尤其是如下事实令人极为失望：

> “通过MSG_OOB可选项传递数据时只返回1个字节？而且也不是很快啊！”

的确！令人遗憾的是，通过MSG_OOB可选项传递数据时不会加快数据传输速度，而且通过信号处理函数urg_handler读取数据时也只能读1个字节。剩余数据只能通过未设置MSG_OOB可选项的普通输入函数读取。这是因为TCP不存在真正意义上的“带外数据”。实际上，MSG_OOB中的OOB是指Out-of-band，而“带外数据”的含义是：

> “通过完全不同的通信路径传输的数据。”

即真正意义上的Out-of-band需要通过单独的通信路径高速传输数据，但TCP不另外提供，只利用TCP的紧急模式（Urgent mode）进行传输。



### 13.1.3 紧急模式工作原理

先给出结论，再补充说明紧急模式。MSG_OOB可选项可以带来如下效果：

> “嗨！这里有数据需要紧急处理，别磨蹭啦！”

MSG_OOB的真正的意义在于督促数据接收对象尽快处理数据。这是紧急模式的全部内容，而且TCP“保持传输顺序”的传输特性依然成立。

> “那怎能称为紧急消息呢！”

这确实是紧急消息！因为发送消息者是在催促数据处理的情况下传输数据的。急诊患者的及时救治需要如下两个条件：

- 迅速入院
- 医院急救

无法快速把病人送收到医院，并不意味着不需要医院进行急救。TCP的紧急消息无法保证及时入院，但可以要求急救。当然，急救措施应由程序员完成。之前的示例oob_recv.c的运行过程中也传递了紧急消息，这可以通过事件处理函数确认。这就是MSG_OOB模式数据传输的实际意义。下面给出设置MSG_OOB可选项状态下的数据传输过程，如下图所示。

<img src="image\13.1.3.png" alt="1" style="zoom:30%;margin:0px;" />

上图给出的是示例oob_send.c的第32行中调用如下函数后的输出缓冲状态。此处假设已传输之前的数据。

```C
send(sock, "890", strlen("890"), MSG_OOB);
```

如果将缓冲最左端的位置视为偏移量为0，字符串0保存于偏移量为2的位置。另外，字符0右侧偏移量为3的位置存有紧急指针（Urgent Pointer）。紧急指针指向紧急消息的下一个位置（偏移量加1），同时向对方主机传递如下消息：

>“紧急指针指向的偏移量为3之前的部分就是紧急消息！”

也就是说，实际只用1个字节表示紧急消息信息。这一点通过上图13-1中用于传输数据的TCP数据包的结构看得更清楚，如下图所示：

<img src="image\13.1.3_2.png" style="zoom:35%;margin:0px;" />

TCP数据包实际包含更多信息，但上图只标注了与我们主题相关的内容。TCP头中含有如下两种信息：

- URG = 1：表示载有紧急消息的数据包
- URG指针：紧急指针位于偏移量为3的位置

指定MSG_OOB选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在位置。但通过上图13-2无法得知以下事实：

> “紧急消息是字符串890，还是90？如若不是，是否为单个字符0？”

但这并不重要。如前所述，除紧急指针的前面1个字节外，数据接收方将通过调用常用输入函数读取剩余部分。换言之，紧急消息的意义在于督促消息处理，而非紧急传输形式受限的消息（也就是重点不在于消息是890还是0这些消息内容，而是督促消息处理）。



### 13.1.4 检查输入缓冲

同时设置MSG_PEEK选项和MSG_DONTWAIT选项，以验证输入缓冲中是否存在接受的数据。设置MSG_PEEK选项并调用recv函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与MSG_DONTWAIT合作，因此调用以非阻塞方式验证待读数据存在与否的函数。下面通过示例了解这两个可选项的含义。

代码参见：

- [peek_send.c](SK13/peek_send.c)

- [peek_recv.c](SK13/peek_recv.c)

  > peek_revc中给出了使用MSG_PEEK和MSG_DONTWAIT选项的结果。

- 运行结果：peek_recv.c

  ```
  Buffering 3 bytes: 123 
  Read agin: 123 
  ```

  通过运行结果可以验证，仅发送1次的数据被读取了2次，因为第一次调用recv函数时设置了MSG_PEEK可选项。以上就是MSG_PEEK可选项的功能。

  关于MSG_PEEK可选项，可以看一下CSDN中的一篇文章的介绍：MSG_PEEK标志会将套接字接收队列中的可读的数据拷贝到缓冲区，但不会使套接字接收队列中的数据减少，常见的是：例如调用recv或read后，导致套接字接收队列中的数据被读取后而减少，而指定了MSG_PEEK标志，可通过返回值获得可读数据长度，并且不会减少套接字接收缓冲区中的数据，所以可以供程序的其他部分继续读取。

  原文链接：https://blog.csdn.net/aspnet_lyc/article/details/28937229



## 13.2 readv & writev函数

本节介绍的readv & writev函数**有助于提高数据通信效率**。先介绍这些函数的使用方法，再讨论其合理的应用场景。

### 13.2.1 使用readv & writev函数

readv & writev函数的功能可概括如下：

> “对数据进行整合传输及发送的函数。”

也就是说，通过writev函数可以将分散保存在多个缓冲中的数据一并发送，通过readv函数可以由多个缓冲分别接收。因此，适当使用这2个函数可以减少I/O函数的调用次数。下面先介绍writev函数。

- **`writev()函数：`**

  ```c
  #include<sys/uio.h>
  ssize_t writev(int filedes, const struct iovec * iov, int invcnt);
  ```

  > 成功时返回发送的字节数，失败时返回-1。
  >
  > 参数1：filedes，表示数据传输对象的套接字文件描述符。但该函数并不只限于套接字，因此，可以像read函数一样向其传递文件或标准输出描述符。
  >
  > 参数2：iov，iovec结构体数组的地址值，结构体iovec中包含待发送的数据的位置和大小信息。
  >
  > 参数3：iovcnt，向第二个参数传递的数组长度。

  上述函数的第二个参数中出现的数组iovec结构体的声明如下：

  ```c
  struct iovec
  {
  	void * iov_base; // 缓冲地址
  	size_t iov_len;	 // 缓冲大小
  }
  ```

  可以看到，结构体iovec由保存待发送数据的缓冲（char型数组）地址值和实际发送的数据长度信息构成。给出上述函数的调用示例前，先通过下图了解该函数的使用方法。

  <img src="image\13.2.1.png" alt="1" style="zoom:35%;margin:0px;" />

  上图中writev的第一个参数1是文件描述符，因此向控制台输出数据，ptr是存有待发送数据信息的iovec数组指针。第三个参数为2，因此，从ptr指向的地址开始，共浏览2个iovec结构体变量，发送这些指针指向的缓冲数据。接下来仔细观察图中的iovec结构体数组。ptr[0]（数组第一个元素）的iov_base指向以A开头的字符串，同时iov_len为3，故发送ABC。而ptr[1]（数组的第二个元素）的iov_base指向数字1，同时iov_len为4，故发送1234。

  

- 代码参见:[writev.c](SK13/writev.c)

- 运行结果：

  ```
  ABC1234 
  Write bytes: 7 
  ```



下面介绍readv函数，它与writev函数正好相反。

- **`readv()函数：`**

  ```c
  #include<sys/uio.h>
  ssize_t readv(int filedes, const struct iovec * iov, int iovcnt);
  ```

  > 成功时返回接收的字节数，失败时返回-1。
  >
  > 参数1：filedes，传递接收数据的文件（或套接字）描述符
  >
  > 参数2：包含数据保存位置和大小信息的iovec结构体数组的地址值。
  >
  > 参数3：iovcnt：第二个参数中数组的长度。

通过示例给出readv函数的使用方法：

- 代码示例：[readv.c](SK13/readv.c)

- 运行结果：

  ```
  i like TCP/IP socket programming!
  Read bytes: 34 
  First message: i lik 
  Second message; e TCP/IP socket programming!
  ```

  从运行结果可知，通过iovec结构体数组变量保存了数据。



### 13.2.2 合理使用readv & writev函数

那种情况适合使用readv和writev函数？实际上，能使用该函数的情况都适用。例如，需要传输的数据分别位于不同缓冲（数组）时，需要多次调用write函数。此时可以通过1次writev函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用read函数，而是利用1次readv函数就能大大提高效率。

即使仅从C语言角度来看，减少函数调用次数也能相应提高性能。但其更大的意义在于减少数据包个数。假设为了提高效率而在服务器端明确阻止了Nagle算法。其实writev函数在不采用Nagle算法时更有价值，如下图所示。

<img src="image\13.2.2.png" style="zoom:50%;margin:0px;" />

上述示例中待发送的数据分别存在3个不同的地方，此时如果使用write函数则需要3次函数调用。但若为提高速度而关闭了Nagle算法，则以有可能通过3个数据包传递数据。反之，若使用writev函数将所有数据一次性写入输出缓冲，则很有可能仅通过1个数据包传输数据。所以writev函数和readv函数非常有用。

再考虑一种情况：将不同位置的数据按照发送顺序移动（复制）到1个大数组，并通过1次write函数调用进行传输。这种方式是否与调用writev函数的效果相同？当然！但是用writev函数更为便利。因此，如果遇到writev函数和readv函数的适用情况，希望各位不要错过机会。



## 13.4 习题

1. 下列关于MSG_OOB可选项的说法错误的是？

   **a.MSG_OOB指传输Out-of-band数据，是通过其他路径高数传输数据。**

   b.MSG_OOB指通过其他路径高速传输数据，因此，TCP中设置该选项的数据先到达对方主机。

   c.设置MSG_OOB使数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点。

   **d.MSG_OOB无法脱离TCP的默认数据传输方式。即使设置了MSG_OOB，也会保持原有传输顺序。该选项只用于要求接收方紧急处理。**

   > 答：上述加粗字体为正确答案。
   >
   > b.运行结果证明，紧急消息并没有加快数据传输速度，这是因为TCP不存在真正意义上的“带外数据”。真正意义上的Out-of-band需要通过单独的通信路径高速传输数据，但TCP不另外提供，只利用TCP的紧急模式（Urgent mode）进行传输。
   >
   > c.通过实验证明，TCP的顺序传输的特点决定了紧急消息按普通消息一样按序读取到应用程序中，而且运行结果表面，接收方可以识别到紧急消息并通过紧急消息信号处理函数进行输出。

2. 利用readv & writev函数收发数据有何优点？分别从函数调用次数和I/O缓冲的角度给出说明。

   > 答：需要传输的数据分别位于不同缓冲（数组）时，需要多次调用write函数。此时可通过1次writev函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用read函数，而是利用1次readv函数就能大大提高效率。

3. 通过recv函数验证输入缓冲是否存在数据时(确认后立即返回时)，如何设置recv函数最后一个参数的可选项？分别说明各可选项的含义。

   > 答：recv函数可以通过MEG_PEEK可选项来确认输入缓冲中是否存在数据，可以结合MEG_DONTWAIT可选项一起使用，则recv函数将成为非阻塞I/O函数作为读取数据，因为MEG_PEEK可选项是从输入缓冲中拷贝数据，所以，数据仍可保留在输入缓冲中。

------





# 第十四章 多播与广播

------

## 14.1 多播

多播的方式（Multicast）方式的数据传输是基于UDP完成的。因此，与UDP服务器端/客户端的实现方式非常接近。区别在于，UDP数据传输与单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，可以同时向多个主机传递数据。

### 14.1.1 多播的数据传输方式以及流量方面的优点

多播的数据传输特点：

- 多播服务器端针对特定多播组，只发送1次数据。
- 即使只发送1次数据，但该组内的所有客户端都会接受数据。
- 多播组数可以在IP地址范围内任意增加。

多播组是D类地址（224.0.0.0 ~ 239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：

> 在D类地址中，我希望接收发往目标239.234.218.234的多播数据。

多播是基于UDP完成的，也就是说，多播数据包的格式与UDP数据包相同。只是与一般的UDP数据包不同。向网络传递1个多播数据报时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如下图所示：

![](image\14.1.1.png)

若通过TCP或UDP向1000个主机发送文件，则共需传递1000次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由1000台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。

另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。

### 14.1.2 路由（Routing）和TTL（Time to Liv，生存时间），以及加入组办法

接下来讨论多播相关编程办法。为了传递多播数据包，必须设置TTL。TTL是Time to Live的简写，是决定“数据包传递距离”的主要因素。TTL用整数表示，并且每经过1个路由器就减1。TTL变为0时，该数据包无法再被传递，只能销毁。因此TTL的值设置过大将影响网络流量。当然，设置过小也会无法传递到目标，需要引起注意。

<img src="image\14.1.2.png" style="zoom:45%;margin:0px;" />

接下来给出TTL设置的方法。程序中的TTL设置是通过第九章的套接字可选项完成的。与上设置TTL相关的协议层为`IPPROTO_IP`，可选项名为`IP_MULTICAST_TTL`。因此，可以通过用如下代码把TTL设置为64。

```c
int send_sock;
int time_live = 64;
...
send_sock = socket(PF_INET, SOCK_DGRAM, 0);
setsockopt(send_sock, IPPROTO_IP, IP_MULTICAST_TTL, (void *)&time_live, sizeof(time_live));
```

另外，加入多播组也通过设置套接字选项完成。加入多播组相关的协议层为IPPROTO_IP选项名为IP_ADD_MEMBERSHIP。可通过如下代码加入多播组。

```c
int recv_sock;
struct ip_mreq join_adr;
...
recv_sock = socket(PF_INET, SOCK_DGRAM, 0);
...
join_adr.imr_multiaddr.s_addr = "多播组地址信息";
join_adr.imr_interface.s_addr = "加入多播组的主机地址信息";
setsockopt(recv_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&join_adr, sizeof(join_adr));
```

上述代码只给出了与setsockopt函数相关的部分，详细内容将在稍后示例中给出。此处只讲解`ip_mreq`结构体，该结构体定义如下：

```c
struct ip_mreq
{
	struct in_addr imr_multiaddr;
	struct in_addr imr_interface;
}
```

> 第一个成员imr_multiaddr中写入加入的组IP地址。
>
> 第二个成员imr_interface是加入该组的套接字所属主机的IP地址，也可以使用INADDR_ANY。

记忆：

- ip_mreq，ip memory request，就是ip地址要请求内存进行存储。
- imr，ip memory request的缩写。



### 14.1.3 实现多播Sender和Receiver

多播中用「发送者 Sender」和「接收者 Receiver」替代服务器端和客户端。顾名思义，此处的Sender是多播数据的发送主体，Receiver是需要多播组加入过程的数据接收主体。下面讨论即将给出的示例，该示例的运行场景如下：

- Sender：向AAA组广播（Broadcasting）文件中保存的新闻信息。
- Receiver：接收传递到AAA组的新闻信息。

接下来给出Sender代码。Sender比Receiver简单，因为Receiver需要经过加入组的过程，而Sender只需创建UDP套接字，并向多播地址发送数据。

- 代码示例：[news_sender.c](SK14/news_sender.c)



从上述代码中可以看到，Sender与普通的UDP套接字程序相比差别不大。但多播Receiver则有些不同。为了接收传向任意多播地址的数据，需要经过加入多播组的过程。除此之外，Receiver同样与UDP套接字程序差不多。接下来给出与上述示例结合使用的Receiver程序。

- [news_receiver.c](SK14/news_receiver.c)



- 运行结果：news_sender.c

  ```
   ./sender 224.0.0.0 5009
  ```

- 运行结果：news_receiver.c

  ```
  ./receiver 224.0.0.0 5009
  one of the host cities of the 2023 Asian Cup, Shanghai is primed to take its soccer industry to the next level.
  
  The city is already considered one of the country's main soccer hubs, in large part due to its renowned youth training academy－Genbao Soccer Base.
  
  Inspired by English giant Manchester United's famed academy, the center was established in 2000 by the so-called "godfather of Shanghai soccer", Xu Genbao, on Chongming Island, located north of the city's downtown area.
  ```

Sender和Receiver之间的端口号应保持一致。运行顺序并不重要，因为不像TCP套接字在连接状态下收发数据。只是因为多播属于广播的范畴，如果延迟运行Receiver，则无法接收之前传输的多播数据。



## 14.2 广播

本节介绍的广播（Broadcast）在「一次性向多个主机发送数据」这一点上与多播类似，但传数据的范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。相反，广播只能向同一网络中的主机传输数据。

### 14.2.1广播的理解及实现方法

广播是同一网络的所有主机传输数据的方法。与多播相同，广播也是基于UDP完成的。根据传输数据时使用的IP地址的形式，广播分为如下2种：

- 直接广播（Directed Broadcast）
- 本地广播（Local Broadcast）

二者在代码实现上的差别主要在于IP地址。直接广播的IP地址中除了网络地址外，其余主机地址全部设置为1。例如，希望向网络地址192.12.34中的所有主机传输数据时，可以向192.12.34.255传输。换言之，可以采用直接广播的方式向特定区域所有主机传输数据。

本地广播的IP地址所有位全部设置为1，所以本地广播中使用的IP地址限定为255.255.255.255。例如192.32.24网络中的主机向255.255.255.255传输数据时，数据将传递到192.32.24网络中的所有主机。

那么应当如何实现Sender和Receiver呢？实际上，如果不仔细观察广播示例中通信时使用的IP地址，则很难与UDP示例进行区分。也就是说，数据通信时使用的IP地址是与UDP示例的唯一区别。默认生成的套接字会阻止广播，因此，只需通过如下代码更改默认设置。

```c
int send_sock;
int bcast = 1;
...
send_sock = socket(PF_INET, SOCK_DGRAM,0);
...
setsockopt(send_sock, SOL_SOCKET, SO_BROADCAST,(void*)&bcast, sizeof(bcast));
```

调用setsockopt函数，将`SO_BROADCAST`选项设置为bcast变量中的值1。这意味着可以进行数据广播。当然，上述套接字选项只需在Sender中更改，Receiver的实现不需要该过程。

### 14.2.1 实现广播数据的Sender和Receiver

下面实现基于广播的Sender和Receiver。

- 代码参见：

  [news_sender_brd.c](SK14/news_sender_brd.c)

  [news_receiver_brd.c](SK14/news_receiver_brd.c)

- 运行结果：news_sender_brd.c

  ```
  ./senderbrd 255.255.255.255 5009 
  ```

- 运行结果：news_receiver_brd.c

  ```
  ./receiverbrd 5009
  one of the host cities of the 2023 Asian Cup, Shanghai is primed to take its soccer industry to the next level.
  
  The city is already considered one of the country's main soccer hubs, in large part due to its renowned youth training academy－Genbao Soccer Base.
  
  Inspired by English giant Manchester United's famed academy, the center was established in 2000 by the so-called "godfather of Shanghai soccer", Xu Genbao, on Chongming Island, located north of the city's downtown area.
  ```

  上面是通过本地广播的运行结果，有条件的话，可以进一步验证直接广播的运行结果。



## 14.4 习题

1. TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题。

   > 答：TTL是time to live 的简写，也就是数据包在网络中的存在的时间，它是决定数据包的传输距离，但TTL的值设置较大，将会影响到网络的网络流量，TTL的值设置较小，数据包将无法到达目标。

2. 多播与广播的异同点是什么？请从数据通信的角度进行说明。

   > 答：共同点:一次性向多个主机发送数据。不同点：传输数据范围不同。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。而广播只能向同一网络中的主机传输数据。

3. 下列关于多播的描述错误的是？

   **a.多播是用来向加入多播组的所有主机传输数据的协议。**

   b.主机连接到同一网络才能加入多播组，也就是说，多播组无法跨越多个网络。

   c.能够加入多播组的主机数并无限制，但只能由1个主机（Sender）向该组发送数据。

   **d.多播时使用的套接字是UDP套接字，因为多播是基于UDP进行数据通信的。**

   > 答：上述加粗字体为正确选项。

4. 多播也对网络有利，请比较TCP数据交换方式解释其原因。

   > 答：TCP提供可靠的通信服务，其中包括用于检验数据包是否传输无误的SEQ和ACK数据包，TCP的可靠性会增加网络中传输的数据包。而多播是基于UDP进行数据通信的，UDP的结构简洁，不具有流控制等概念，而所以多播传输能够减少网络中的数据包，进而提高网络的传输效率。
   >
   > 另一种角度：TCP是必须建立一对一的连接，如果要向1000个主机发送文件，就得传递1000次。但是此时用多播方式传输数据，就只需要发送一次。

5. 多播方式的数据通信需要Mbone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处的“虚拟网络”。

   > 答：可以理解为“通过网络中的特殊协议工作的软件概念上的网络」。也就是说，MBone并非刻意触及的物理网络。他是以物理网络为基础，通过软件方式实现的多播通信必备虚拟网络。


------



# 第十五章 套接字和标准IO

## 15.1 标准I/O函数的优点

### 15.1.1 标准I/O函数的两个优点

- 标准I/O函数具有良好的移植性（Portability）
- 标准I/O函数可以利用缓冲提高性能。

创建套接字时，操作系统将生成用于I/O的缓冲。此缓冲在执行TCP协议时发挥着非常重要的作用。此时若使用标准I/O函数，将得到额外的另一缓冲的支持，如下图所示：

<img src="image\15.1.1.png" style="zoom:50%;margin:0px;" />

可以看到，使用标准I/O函数传输数据时，经过2个缓冲。例如，通过fputs函数传输字符串“Hello”时，首先将数据传递到标准I/O函数的缓冲。然后数据将移动到套接字输出缓冲，最后将字符串发送到对方主机。

既然知道了两个缓冲的关系，接下来在说明各自的用途。设置缓冲的主要目的是为了提高性能，但套接字中的缓冲主要是为了实现TCP协议而设立的。例如，TCP传输中丢失数据时将再次传递，而再次发送数据则意味着在某地保存了数据。存在什么地方呢？套接字的输出缓冲。相反，使用标准I/O函数缓冲的主要目的是为了提高性能。

> “使用缓冲可以大大提高性能吗？”

实际上，缓冲并非在所有情况下都能带来卓越的性能。但需要传输的数据越多，有无缓冲带来的性能差异越大。可以通过如下两种角度说明性能的提高。

- 传输的数据量
- 数据向输出缓冲移动的次数

比较1个字节的数据发送10次（10个数据包）的情况和累计10个字节发送1次的情况。发送数据时使用的数据包中含有头信息。头信息与数据大小无关，是按照一定的格式填入的。即使假设该头部占用40个字节（实际更大），需要传递的数据量也存在较大差别。

- 1个字节10次：40x10 = 400字节
- 10个字节1次：40x1 = 40字节

另外，为了发送数据，向套接字输出缓冲移动数据也会消耗不少时间。但这同样与移动次数有关。1个字节数据共移动10次花费的时间将近10个字节数据移动1次花费时间的10倍。



### 15.1.2 标准I/O函数和系统函数之间的性能对比

前面讲解了缓冲可以提升性能的原因，但只停留在理论分析层面。接下来分别利用标准I/O函数和系统函数编写文件复制程序，这主要是为了检验缓冲提高性能的程度。

下面是利用系统函数的示例：

- [syscpy.c](SK15/syscpy.c)

下面是利用标准I/O函数的示例：

- [stdcpy.c](SK15/stdcpy.c)

可见利用标准I/O函数进行复制，效率会非常高。可以看一下这篇文章[Linux系统调用和库函数调用的区别](https://blog.csdn.net/hxllhhy/article/details/72909433)。



### 15.1.3 标准I/O函数的几个缺点

- 不容易进行双向通信
- 有时可能频繁调用fflush函数
- 需要以FILE结构体指针的形式返回文件描述符

因为缓冲的缘故，每次需要切换读写工作状态时应调用fflush函数。这也会影响基于缓冲的性能提高。而且，为了使用标准I/O函数，需要FILE结构体指针（以下简称“FILE指针”）。而创建套接字时默认返回文件描述符，因此需要将文件描述符转化为FILE指针。



## 15.2 使用标准I/O函数

创建套接字时返回文件描述符，而为了使用I/O函数，只能将其转换为FILE结构体指针。先介绍其转换方法。

### 15.2.1 利用fdopen函数转换为FILE结构体指针

可以通过fdopen函数将创建套接字返回的文件描述符转换为标准I/O函数中使用的FILE结构体指针。

```c
#include<stdio.h>
FILE * fdopen(int fildes, const char * mode);
```

> 成功时返回转换的FILE结构体指针，失败时返回NULL。
>
> 参数1：fildes，需要转换的文件描述符。
>
> 参数2：mode，将要创建的FILE结构体指针的模式（mode）信息。

上述函数的第二个参数与fopen函数中的打开模式相同。常见的参数有读模式"r"和写模式"w"。下面通过示例给出fdopen函数的使用方法：

- 代码参见：[desto.c](SK15/desto.c)

- 运行结果：

  ```
  gcc desto.c -o desto
  SK15# ./desto
  cat data.dat
  Network C programming 
  ```





### 15.2.2 利用fileno函数转换为文件描述符

接下来介绍与fdopen函数提供相反功能的函数。

```c
#include<stdio.h>
int fileno(FILE * stream);
```

> 成功时返回转换后的文件描述符，失败时返回-1。

接下来给出fileno的调用示例：

- 代码参见：[todes.c](SK15/todes.c)

- 运行结果：

  ```
  gcc todes.c -o todes
  ./todes
  First file descriptor: 3 
  Second file descriptor: 3 
  ```



## 15.3 基于套接字的标准I/O函数使用

前描介绍了标准I/O函数的优缺点，同时介绍了文件描述符转换为FILE指针的方法。下面将其适用于套接字。

接下来将之前的回声服务器端和客户端改为标准I/O函数的数据交换形式，更改对象如下 ：

回声服务器端：第四章的[echo_server.c](SK04/echo_server.c)

回声客户端：第四章的[echo_client.c](SK04/echo_client.c)

- 更改后的服务器端代码：[echo_server.c](SK15/echo_server.c)

- 更改后的客户端代码：[echo_client.c](SK15/echo_client.c)

第四章的回声客户端需要将接收的数据转换为字符串（数据的尾部插入0），但上述示例中并没有这一过程。因为，使用标准I/O函数后可以按字符串单位进行数据交换。运行结果与第四章的过程并无差异，故省略。



## 15.4 习题

1. 请说明标准I/O函数的2个优点。它为何拥有这2个优点？

   > 答：优点：①标准I/O函数具有可移植性；②标准I/O函数可以利用缓冲提高性能。
   >
   > 原因：为了能够在多平台下运行，制定出统一的标准。标准I/O函数充分利用缓冲可以减少对内核系统函数的调用次数，减少用户空间与内核空间切换产生的开销。

2. 利用标准I/O函数传输数据时，下面的想法是错误的：

   “调用fputs函数传输数据时，调用后应立即开始发送！”

   为何说上述想法是错误的？为了达到这种效果应添加哪些处理过程？

   > 答：fputs传输的数据只是写入到缓冲中，而且由于fputs是行缓冲，实现立即发送，则应利用fflush将用户缓冲传递到内核缓冲，内核缓冲中的数据再通过write将数据发送出去。

------





# 第十六章 关于I/O流分离的其他内容

------

调用fopen函数打开文件后可以与文件交换数据，因此说调用fopen函数创建了「流」（Stream）。此处的「流」是指「数据流动」，但通常可以比喻为“以数据收发为目的的一种桥梁”。

## 16.1 分离I/O流

“分离I/O”是一种常用表达。有I/O工具可以区分二者，无论使用何种方法，都可以认为分离了I/O流。

### 16.1.1 2 次I/O流分离

我们之前通过2种方法分离过I/O流

1. 第一种是第10章的“TCP I/O过程（Routine）分离” 用于客户端。

   > 这种方法通过调用fork函数复制出1个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了2个文件描述符的用途，因此这也属于“流”的分离。

2. 第二种分离在第15章。通过2次fdopen函数的调用，创建读模式FILE指针（FILE结构体指针）和写模式FILE指针。换言之，我们分离了输入工具和输出工具，因此，也可视为“流”的分离。

下面说明分离的理由，讨论尚未提及的问题并给出解决方法。

### 16.1.2 分离“流”的好处

第10章的“流”分离和第15章的“流”分离在目的上有一定差异。

首先分析第十章的“流”分离目的：

- 通过分开输入过程（代码）和输出过程降低实现难度。
- 与输入无关的输出操作可以提高速度。（并行）

接下来给出第十五章的“流”分离的目的：

- 为了将FILE指针按读模式和写模式加以区分。
- 可以通过区分读写模式降低实现难度。
- 通过区分I/O缓冲提高缓冲性能。

“流”分离的方法、情况（目的）不同时，带来的好处也有所不同。



### 16.1.3 “流”分离带来的EOF问题

下面讲解“流”分离带来的问题。第7章介绍过EOF的传递方法和半关闭的必要性。各位应该还记得如下函数调用语句：

```C
shutdown(sock, SHUT_WR);
```

当时学习过调用shutdown函数的基本半关闭的EOF传递方法。第10章还利用这些技术在[echo_mpclient.c](SK10/echo_mpclient.c)实例中添加了半关闭相关代码。也就是说，第10章的“流”分离没有问题。但第15章的基于fdopen函数的“流”则不同，我们还不知道在这情况下如何进行半关闭，因此有可能犯如下错误：

> “半关闭？不是可以针对输出模式的FILE指针调用fclose()函数吗？这样可以向对方传递EOF，编程可以接受数据但无法发送数据的半关闭状态呀。”

各位是否也这么认为？这是一种很好的猜测，但希望大家先阅读下列代码。另外，接下里的示例种为了简化代码而未添加异常处理，希望各位不要误解。先给出服务器端代码。

代码参见：

- 服务器端：[sep_serv.c](F:/share_ftp/SK/SK16/sep_serv.c)
- 客户端：[sep_clnt.c](F:/share_ftp/SK/SK16/sep_clnt.c)

需要验证的是服务器端第39行的函数调用能否接收。

- 运行结果：服务器端

  ```
  ./serv 5009
  ```

- 运行结果：客户端：

  ```
  ./clnt 127.0.0.1 5009
  FROM SERVER: Hi~ client? 
  I love all of the world 
  You are awesome! 
  ```

从运行结果得出如下结论：

> “服务器端未能接收最后的字符串！”

很容易判断其原因：sep_serv.c示例的第38行调用的fclose函数完全终止了套接字，而不是半关闭。以上就是需要通过本章解决的问题。半关闭在多种情况下都非常有用，各位必须能够针对`fdopen`函数调用时生成的FILE指针进行半关闭操作。



## 16.2 文件描述符的复制和半关闭

本章主题虽然是针对FILE指针的半关闭，但本节介绍的dup和dup2函数也有助于增加系统编程经验。

### 16.2.1 终止“流”时无法半关闭的原因

下图描述的是[`sep_serv.c`](F:/share_ftp/SK/SK16/sep_serv.c)示例中的2个FILE指针、文件描述符及套接字之间的关系。

<img src="image\16.2.1.png" alt="1" style="zoom:30%;margin:0px;" />

从上图16-1可以看到，示例sep_serv.c中的读模式FILE指针和写模式FILE指针都是基于同一文件描述符创建的。因此，针对任意一个FILE指针调用fclose函数时都会关闭文件描述符，也就终止套接字。如下图16-2所示。

<img src="image\16.2.1_2.png" style="zoom:35%;margin:0px;" />

从上图16-2中可以看到，销毁套接字时再也无法进行数据交换。那如何进入可以输入但无法输出的半关闭状态呢?其实很简单。如下图16-3所示，创建FILE指针前先复制文件描述符即可。

<img src="image\16.2.1_3.png" style="zoom:37%;margin:0px;" />

如上图16-3所示，复制后另外创建1个文件描述符，然后利用各自的文件描述符生成读模式FILE指针和写模式FILE指针。这就为半关闭准备好了环境，因为套接字和文件描述符之间具有如下关系：

> “销毁所有文件描述符后才能销毁套接字。”

也就是说，针对写模式FILE指针调用fclose函数时，只能销毁与该FILE指针相关的文件描述符，无法销毁套接字（参考下图）。

<img src="image\16.2.1_4.png" style="zoom:47%;margin:0px;" />

上图所示，调用fclose函数后还剩1个文件描述符，因此没有销毁套接字。那此时的状态是否为半关闭状态？不是！图16-3中讲过，只是准备好了半关闭环境。要进入真正的半关闭状态需要特殊处理。

> “上图16-4中好像已经进入了半关闭状态了呀？”

当然可以这么看。但仔细观察，还剩1个文件描述符呢。而且该文件描述符可以同时进行I/O。因此，不但没有发送EOF，而且仍然可以利用文件描述符进行输出。[理解：半关闭状态，也就是关闭流的一半，这里服务器端需要关闭的是输出流，上图中关闭的是写模式的FILE结构体指针，实际上仅仅是关闭了文件描述符中的一个副本，并没有关闭套接字的输出流。半关闭实质就是关闭输出流要么输入流，所以此操作还没能够进入半关闭状态，套接字的输入输出流依旧没变。]

稍后将介绍根据图16-3和图16-4的模型发送EOF并进入半关闭状态的方法。首先介绍如何复制文件描述符，之前的fork函数不在考虑范围内。



### 16.2.2 复制文件描述符

之前提到的文件描述符的复制与fork函数中进行的复制有所区别。调用fork函数时将复制整个进程，因此同一进程内不能同时有原件和副本。但此处讨论的复制并非针对整个进程，而是在同一进程内完成描述符的复制，如下图所示。

<img src="image\16.2.2..png" style="zoom:40%;margin:0px;" />

上图给出的是同一进程内 存在2个文件描述符可以同时访问文件的情况。当然，文件描述符的值不能重复，因此各使用5和7的整数值。为了形成这种结构，需要复制文件描述符。此处所谓的“复制”具有如下含义：

> “为了访问同一文件或套接字，创建另一个文件描述符。”

通常的“复制”很容易让人理解为将包括文件描述符整数值在内容的所有内容进行复制，而此处“复制”方式却不同。

### 16.2.3 dup & dup2

下面给出文件描述符的复制方法，通过下列2个函数之一完成。

```c
#include<unistd.h>
int dup(int fildes);
int dup2(int fildes, int fildes2);
```

> 成功时返回复制的文件描述符，失败时返回-1。
>
> 参数1：fildes，需要复制的文件描述符。
>
> 参数2：fildes2，明确指定的文件描述符整数值。

dup2函数明确指定复制的文件描述符整数值。向其传递大于0且小于进程能生成的最大文件描述符值时，该值将称为复制出的文件描述符值。

下面给出示例验证函数功能，示例中将复制自动打开的标准输出的文件描述符1，并利用复制出的描述符进行输出。另外，自动打开的文件描述符0、1、2与套接字文件描述符没有区别，因此可以用来验证dup函数的功能。

- 代码参见：[dup.c](F:/share_ftp/SK/SK16/dup.c)

- 运行结果：

  ```
  fd1 = 3, fd2 = 7 
  C++ 
  I love C++!
  C++ 
  ```

  结果表明，销毁所有标准输出文件描述符后，才能断开标准输出流。



### 16.2.4 复制文件描述符后“流”的分离

下面更改set_serv.c和sep_clnt.c示例，使其能够正常工作（只需更改sep_serv.c示例）。所谓“正常工作”是指，通过服务器端的半关闭状态接收客户端最后发送的字符串。当然，为了完成这一任务，服务器端需要同时发送EOF。

- 代码示例：[sep_serv2.c](SK16/sep_serv2.c)

- 运行结果：

  ```
  ./sep_serv2 5009  
  FROM CLIENT: Thank you! 
  ```

  运行结果证明服务器端在半关闭状态下向客户端发送了EOF。通过该示例希望各位掌握一点：

  > “无论复制出多少文件描述符，均应调用shutdown函数发送EOF并进入半关闭状态。”



## 16.3 习题

1. 下列关于FILE结构体指针和文件描述符的说法错误的是？

   a.与FILE结构体指针相同，文件描述符也分为输入描述符和输出描述符。

   b.复制文件描述符时将生成相同值的描述符，可以通过这2个描述符进行I/O。

   c.可以利用创建套接字时返回的文件描述符进行I/O，也可以不通过文件描述符，直接通过FILE结构体指针完成。

   **d.可以从文件描述符生成FILE结构体指针，而且可以利用这种FILE结构体指针进行套接字I/O。**

   e.若文件描述符为读模式，则基于该描述符生成的FILE结构体指针同样是读模式；若文件描述符为写模式，则基于该描述符生成的FILE结构体指针同样是写模式。

   > 答：上述加粗字体为正确答案。
   >
   > b.复制的文件描述符的值与原文件描述符的值不同。
   >
   > c.不能直接通过FILE结构体指针，还需调用fdopen()函数。
   >
   > d.正确：FILE结构体的缓冲的数据最终会流向套接字I/O

2. EOF的发送相关描述错误的是？

   a.终止文件描述符时发送EOF。

   **b.即使未完成终止文件描述符，关闭输出流时也会发送EOF。**

   c.如果复制文件描述符，则包括复制的文件描述符在内，所有描述符都终止时才会发送EOF。

   **d.即使复制文件描述符，也可以通过调用shutdown函数进入半关闭状态并发送EOF。**

   > 答：上述加粗为正确答案。
   >
   > a.终止所有文件描述符才发送EOF。
   >
   > b.正确：关闭输出流即关闭流的一半，也就是调用了shutdown()，发送EOF。
   >
   > c.当遇到d描述的情况时，就不对了。

------





# 第十七章 优于select的epoll

------

实现I/O复用的传统方法有select函数和poll函数。我们介绍了select函数的使用方法，但各种原因导致这些方法无法得到令人满意的性能。因此有了Linux下的epoll、BSD的kqueue、Solaris的/dev/poll和Windows的IOCP等复用技术。本章将讲解Linux的epoll技术。

## 17.1 epoll理解及应用

select复用方法其实由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时接入上百个客户端（当然，硬件性能不同，差别也很大）。这种select方式并不适合以Web服务器端开发为主流的现代开发环境，所以要学习Linux平台下的epoll。

### 17.1.1 基于select的I/O复用技术速度慢的原因

第12章曾实现过基于select的I/O复用服务器端，很容易从代码上分析出不合理的设计，最主要的两点如下:

- 调用select函数后常见的针对所有文件描述符的循环语句。
- 每次调用select函数时都需要向该函数传递监视对象信息。

相比于循环语句，实际上影响性能的最大因素是每次传递监视对象信息。因为传递监视对象信息具有如下含义：

> “每次调用select函数时向操作系统传递监视对象信息。”

应用程序向操作系统传递数据将对程序造成很大负担，而且无法通过优化代码解决，因此将称为性能上的致命弱点。

> “那为何需要把监视对象信息传递给操作系统呢？”

有些函数不需要操作系统的帮助就能完成功能，而有些则必须借助于操作系统。假设各位定义了四则运算相关函数，此时无需操作系统的帮助。但select函数与文件描述符有关，更准确地说，select是监视套接字变化的函数。而套接字是由操作系统管理的，所以select函数绝对需要借助于操作系统才能完成功能。select函数的这一缺点可以通过如下方式弥补：

> “仅向操作系统传递1次监视对象，监视范围或内容发生变化时只通知发生变化的事项。”

这样就无需每次调用select函数时都向操作系统传递监视对象信息，但前提是操作系统支持这种处理方式。Linux的支持方式是epoll，Windows的支持方式是IOCP。



### 17.1.2 select也有优点

本章的epoll方式只在Linux下提供支持，也就是说，改进的I/O复用模型不具有兼容性。相反，大部分操作系统都支持select函数。只要满足或要求如下两个条件，即使在Linux平台也不应拘泥于epoll。

- 服务器端接入者少。
- 程序应具有兼容性。

实际不存在适用于所有情况的模型。应理解各种模型的优缺点，并具备合理运用这些模型的能力。



### 17.1.3 实现epoll时必要的函数和结构体

能够克服select函数缺点的epoll函数具有如下优点，这些优点正好与之前的select函数缺点相反：

- 无需编写以监视状态变化为目的的针对所有文件描述符的循环语句。
- 调用对应于select函数的epoll_wait函数时无需每次传递监视对象信息。

下面介绍epoll服务器端实现中需要的3个函数，请结合epoll函数的优点理解这些函数的功能：

- `epoll_create`：创建保存epoll文件描述符的空间。
- `epoll_ctl` ：向空间注册并注销文件描述符。
- `epoll_wait`：与select函数类似，等待文件描述符发生变化。

select方式中为了保存监视对象文件描述符，直接声明了fd_set变量。但epoll方式下由操作系统负责保存监视对象文件描述符， 因此需要向操作系统请求创建保存文件描述符的空间，此时用的函数就是epoll_create。

此外，为了添加和删除监视对象文件描述符，select方式中需要`FD_SET`、`FD_CLR`函数。但在epoll方式中，通过`epoll_ctl`函数请求操作系统完成。最后，select方式下调用`select`函数等待文件描述符的变化，而epoll调用`epoll_wait`函数。还有，select方式中通过fd_set变量查看监视对象的状态变化（事件发生与否），而epoll方式中通过如下结构体epoll_event将发生变化的（发生事件的）文件描述符单独集中到一起。

```c
struct epoll_event
{
    __unit32_t events;
    epoll_data_t data;
}
typedef union epoll_data
{
    void* ptr;
    int fd;
    __unit32_t u32;
    __unit64_t u64;
}epoll_data_t;
```

声明足够大的epoll_event结构体数组后，传递给epoll_wait函数时，发生变化的文件描述符信息将被填入该数组。因此，无需像select函数那样针对所有文件描述符进行循环。

以上就是epoll中需要的函数和结构体。



### 17.1.4 epoll_create

- **`epoll_create():`**

  ```c
  #include<sys/epoll.h>
  int epoll_create(int size);
  ```

  > 成功时返回epoll文件描述符，失败时返回-1。
  >
  > 参数：size，epoll实例的大小。

  调用epoll_create函数时创建的文件描述符保存空间称为「epoll例程」，但有些情况下名称不同，需要稍加注意。通过参数size传递的值决定epoll例程的大小，但该值只是向操作系统提的建议。换言之，size并非用来决定那个epoll例程的大小，而仅供操作系统参考。

  | 操作系统将完全忽略传递给epoll_create的参数                   |
  | ------------------------------------------------------------ |
  | Linux2.6.8之后的内核完全忽略传入epoll_create函数的size参数。 |



### 17.1.5 epoll_ctl

生成epoll例程后，应在其内部注册监视对象文件描述符，此时使用epoll_ctl函数。

- **`epoll_ctl():`**

  ```c
  #include<sys/epoll.h>
  int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);
  ```

  > 成功时返回0，失败时返回-1。
  >
  > 参数1：epfd，用于注册监视对象的epoll例程的文件描述符。
  >
  > 参数2：op，用于指定监视对象的添加、删除或更改等操作。
  >
  > 参数3：fd，需要注册的监视对象文件描述符。
  >
  > 参数4：event，监视对象的事件类型。

  与其他epoll函数相比，该函数多少有些复杂，但通过调用语句就很容易理解。假设按照如下形式调用epoll_ctl函数：

  ```
  epoll_ctl(A, EPOLL_CTL_ADD, B, C);
  ```

  > 第二个参数`EPOLL_CTL_ADD`意味着“添加”，因此上述语句具有如下含义：
  >
  > “epoll例程A中注册文件描述符B，主要目的是监视参数C中的事件。”

  再介绍一个调用语句：

  ```
  epoll_ctl(A, EPOLL_CTL_DEL, B, NULL);
  ```

  > 上述语句中第二个参数`EPOLL_CTL_DEL`指“删除”，因此该语句具有如下含义：
  >
  > “从epoll例程A中删除文件描述符B。”

  从上述调用语句可以看到，从监视对象中删除时，不需要监视类型（事件），因此向第四个参数传递NULL。

  

  接下来介绍向epoll_ctl第二个参数传递的常量及含义：

  - `EPOLL_CTL_ADD`：将文件描述符注册到epoll例程。
  - `EPOLL_CTL_DEL`：从epoll例程中删除文件描述符。
  - `EPOLL_CTL_MOD`：更改注册的文件描述符的关注事件发生情况。

  关于EPOLL_CTL_MOD常量稍后讲解。如前所述，向epoll_ctl的第二个参数传递EPOLL_CTL_DEL时，应同时向第四个参数传递NULL。

  

  下面讲解各位不太熟悉的epoll_ctl函数的第四个参数，其类型是之前讲过的epoll_event结构体指针。

  > "啊？前面不是已经说了epoll_event用于保存发生变化的（发生事件）的文件描述符吗？"

  是的，如前所述，`epoll_event`结构体用于保存发生事件的文件描述符集合。但也可以在epoll例程中注册文件描述符时，用于注册关注的事件。函数中`epoll_event`结构体的定义并不显眼，因此通过调用语句说明该结构体在epoll_ctl函数中的应用。

  ```c
  struct epoll_event event;
  ...
  event.events = EPOLLIN;	//发生需要读取数据的情况（事件）时
  event.data.fd = sockfd;
  epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);
  ...
  ```

  上述代码将sockfd注册到epoll例程epfd中，并在需要读取数据的情况下产生相应事件。

  接下来给出epoll_event变量的成员events中可以保存的常量及所指的事件类型：

  | EPOLL_CTL_MOD常量 | 事件类型                                                     |
  | :---------------: | ------------------------------------------------------------ |
  |      EPOLLIN      | 需要读取数据的情况                                           |
  |     EPOLLOUT      | 输出缓冲为空，可以立即发送数据的情况                         |
  |     EPOLLPRI      | 收到OOB数据的情况                                            |
  |    EPOLLRDHUB     | 断开连接或半关闭的情况，这在边缘触发方式下非常有用。         |
  |     EPOLLERR      | 发生错误的情况                                               |
  |      EPOLLET      | 以边缘触发的方式得到事件通知。                               |
  |   EPOLLONESHOT    | 发生一次事件后，相应文件描述符不再收到事件通知。因此需要向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD,再次设置事件。 |



### 17.1.6 epoll_wait

最后介绍与select函数对应的epoll_wait函数，epoll相关函数中默认最后调用该函数。

- **`epoll_wait()`**

  ```c
  #include<sys/epoll.h>
  int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);
  ```

  > 成功时返回发生事件的描述符总数，失败时返回-1。
  >
  > 参数1：epfd，表示事件发生监视范围的epoll例程的文件描述符。
  >
  > 参数2：events，保存发生事件的文件描述符集合的结构体地址值。
  >
  > 参数3：maxevents，第二个参数中可以保存的最大事件数。
  >
  > 参数4：timeout，以1/1000秒为单位的等待时间，传递-1时，一直等待直到发生事件。

  该函数的调用方法如下。需要注意的是，第二个参数所指定缓冲需要动态分配。

  ```C
  int event_cnt;
  struct epoll_event* ep_events;
  ...
  ep_events = malloc(sizeof(struct epoll_event)*EPOLL_SIZE); //EPOLL_SIZE是宏常量
  ...
  events_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
  ```

  调用函数后，返回发生事件的文件描述符，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。因此，无需像select那样插入针对所有文件描述符的循环。



### 17.1.7 基于epoll的回声服务器端

代码参见：[echo_epollserv.c](SK17/echo_epollserv.c)



## 17.2 条件触发和边缘触发

有些人学习epoll时往往无法正确区分「条件触发」(Level Trigger) 和「边缘触发」(Edge Triger)，但只有理解了二者区别才算完整掌握epoll。

### 17.2.1 条件触发和边缘触发的区别在于发生事件的时间点

- 条件触发的特性：

  > 条件触发方式中，只要输入缓冲有数据就会一直通知该事件。

  例如，服务器端输入缓冲收到50字节的数据时，服务器端操作系统将通知该事件（注册到发生变化的文件描述符）。但是服务器端读取20字节后还剩下30字节的情况下，仍会注册事件。也就是说，条件触发方式中，只要输入缓冲中还剩有数据，就将以事件方式再次注册。

  

- 边缘触发的事件特性：

  > 边缘触发中输入缓冲收到数据时仅注册1次该事件。即使输入缓冲中还留有数据，也不会再次进行注册。



### 17.2.2 掌握条件触发的事件特性

接下来通过代码了解条件触发的事件注册方式。下列代码是稍微修改之前的[echo_epollserv.c](SK17/echo_epollserv.c)示例得到的。epoll默认以条件触发方式工作，因此可以通过该示例验证条件触发的特性。

- 代码参见：[echo_EPLTserv.c ](F:/share_ftp/SK/SK17/echo_EPLTserv.c )

> 上述示例与之前的echo_epollserv.c之间的差异如下：
>
> - 将调用read函数时使用的缓冲大小缩减为4字节
>
> - 插入验证epoll_wait函数调用次数的语句。
>
>   > `puts("return epoll_wait");`

减少缓冲大小是为了阻止服务器端一次性读取接收的数据，以便观察。换言之，调用read函数后，输入缓冲中仍有数据需要读取。而且会因此注册新的事件并从epoll_wait函数返回时将循环输出`return epoll_wait`字符串。

- 运行结果：echo_EPLTserv.c

  ```
  ./EPLTserv 23
  return epoll_wait
  connected client: 5 
  return epoll_wait
  return epoll_wait
  return epoll_wait
  return epoll_wait
  connected client: 6 
  return epoll_wait
  return epoll_wait
  return epoll_wait
  return epoll_wait
  return epoll_wait
  return epoll_wait
  closed client: 5 
  return epoll_wait
  closed client: 6 
  ```

- 运行结果：第4章的echo_client.c one

  ```
  ./eclient 127.0.0.1 23
  Connected........
  Input message(Q to quit):I love C++!
  Message from server: I love C++!
  Input message(Q to quit):q
  ```

- 运行结果：第4章的echo_client.c  two

  ```
  ./eclient 127.0.0.1 23
  Connected........
  Input message(Q to quit):I love Programming!
  Message from server: I love Programming!
  Input message(Q to quit):q
  ```

从运行结果中可以看出，每当收到客户端数据时，都会注册该事件，并因此多次调用epoll_wait函数。下面将上述示例改成边缘触发方式，需要做一些额外的工作。将下面代码这一行进行改写：

```C
clnt_sock = accept(...)
event.events = EPOLLIN; //改动这一行
```

改成：

```C
event.events = EPOLLIN|EPOLLET;
```

更改后可以验证如下事实：

> “从客户端接收数据时，仅输出1次`return epoll_wait`字符串，这意味着仅注册1次事件。”

虽然可以验证上述事实，当客户端运行时将发生错误。但如果理解了边缘触发的特性，应该可以分析出错误原因。

| select模型是条件触发还是边缘触发                             |
| ------------------------------------------------------------ |
| select模型是以条件触发的方式工作的，输入缓冲中如果还剩有数据，肯定会注册事件。 |



### 17.2.3 边缘触发的服务器端实现中必知的两点

下面讲解边缘服务器端的实现方法。

实现边缘触发的必知内容：

- 通过errno变量验证错误原因。
- 为了完成非阻塞（Non-blocking）I/O，更改套接字特性。

Linux的套接字相关函数一般通过返回-1通知发生错误。虽然知道发生了错误，但仅凭这些内容无法得知产生错误的原因。因此，为了在发生错误时提供额外的信息，Linux声明了如下全局变量：

```
int errno;
```

为了访问该变量，需要引入error.h头文件，因为此头文件中有上述变量的extern声明。另外，每种函数发生错误时，保存到errno变量中的值都不同，没必要记住所有可能的值。学习每种函数的过程中逐一掌握，并能在必要时参考即可。本节只介绍如下类型的错误：

> “read函数发现输入缓冲中没有数据可读时返回-1，同时在errno中保存EAGAIN常量。”

稍后通过示例给出errno的使用方法。下面讲解将套接字改为非阻塞方式的方法。

Linux提供更改或读取文件属性的方法：

```c
#include<fcntl.h>
int fcntl(int filedes, int cmd, ...);
```

> 成功时返回cmd参数相关值，失败时返回-1。
>
> 参数1：filedes，属性更改目标的文件描述符。
>
> 参数2：cmd，表示函数调用的目的。

> 从上述声明中可以看到，fcntl具有可变参数的形式。如果向第二个参数传递`F_GETFL`，可以获得第一个参数所指的文件描述符属性（int型）。反之，如果传递`F_SETFL`，可以更改描述符属性。若希望将文件（套接字）改成非阻塞方式，需要如下2条语句。
>
> ```C
> int flag = fcntl(fd, F_GETFL, 0);
> fcntl(fd, F_SETFL, flag| O_NONBLOCK);
> ```
>
> 通过第一条语句获取之前设置的属性信息，通过第二条语句在此基础上添加非阻塞`O_NONBLOCK`标志。调用read&write函数时，无论是否存在数据，都会形成非阻塞文件（套接字）。fcntl函数的适用范围很广，各位既可以在学习系统编程时一次性总结所有适用情况，也可以每次需要时注意掌握。



### 17.2.4 实现边缘触发的回声服务器端

之所以介绍读取错误原因的方法和非阻塞模式的套接字创建方法，原因在于二者都与边缘触发的服务器端实现有密切联系。首先说明为何需要通过errno确认错误原因。

> “边缘触发方式中，接收数据时仅注册1次该事件。”

就因为这种特性，一旦发生输入相关事件，就应该读取输入缓冲中的全部数据。因此需要验证输入缓冲是否为空。

> “read函数返回-1，且变量errno中的值为EAGAIN时，说明没有数据可读。”

既然如此，为何还需要将套接字变成非阻塞模式？边缘触发方式下，以阻塞方式工作的read&write函数有可能引起服务器端的长时间停顿。因此，边缘触发方式中一定要采取非阻塞read&write函数。接下来给出以边缘触发方式工作的回声服务器端示例。

- 代码参见：[echo_EPETserv.c](SK17/echo_EPETserv.c)

- 运行结果：echo_EPETserv.c

  ```
  ./EPETserv 5009    
  return epoll_wait
  connected client: 5
  return epoll_wait
  return epoll_wait
  return epoll_wait
  closed client 5
  ```

- 运行结果：第4章echo_client.c

  ```
  ./eclient 127.0.0.1 5009
  Connected........
  Input message(Q to quit):hello
  Message from server: hello
  Input message(Q to quit):TCP/IP
  Message from server: TCP/IP
  Input message(Q to quit):q
  ```

上述运行结果中需要注意的是，客户端发送消息次数和服务器端epoll_wait函数调用次数。客户端从请求连接到断开连接共发送4次数据，服务器端也相应产生4个事件。



### 17.2.5 条件触发和边缘触发孰优孰劣

我们从理论和代码的角度充分理解了条件触发和边缘触发，但仅凭这些无法理解边缘触发相对于条件触发的优点。边缘触发方式下可以做到如下这点：

> “可以分离接收数据和处理数据的时间点！”

<img src="image\17.2.5.png" alt="1" style="zoom:60%;margin:0px;" />

上图运行流程如下：

1. 服务器端分别从客户端A、B、C接收数据。
2. 服务器端按照A、B、C的顺序重新组合收到的数据。
3. 组合的数据将发送给任意主机。

为了完成该过程，若能按如下流程运行程序，服务器端的实现并不难。

1. 客户端按照A、B、C的顺序连接服务器端，并依序向服务器端发送数据。
2. 需要接收数据的客户端应在客户端A、B、C之前连接到服务器端并等待。

但现实中可能频繁出现如下这些情况，换言之，如下情况更符合实际。

1. 客户端C和B正向服务器端发送数据，但A尚未连接到服务器端。
2. 客户端A、B、C乱序发送数据。
3. 服务器端已收到数据，但要接收数据的目标客户端还未连接到服务器端。

因此，即使输入缓冲收到数据（注册相应事件），服务器端也能决定读取和处理这些数据的时间点，这样就给服务器端的实现带来巨大的灵活性。

> “条件触发中无法区分数据接收和处理吗？”

并非不可能。但在输入缓冲收到数据的情况下，如果不读取（延迟处理），则每次调用epoll_wait函数时都会产生相应事件。而且事件数也会累加，服务器端能承受吗？这在现实中是不可能的（本身并不合理，因此是根本不想做的事）。

条件触发和边缘触发的区别主要应该从服务器端实现模型的角度谈论，而重点不在于两者之间的速度差距。



## 17.3 习题

1. 利用select函数实现服务器端时，代码层面存在的2个缺点是？

   > 答：①每次调用select函数都要针对所有文件描述符的循环语句；②每次调用select函数时都要向其传递注册的文件描述符信息。

2. 无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因。

   > 答：因为文件描述符是由操作系统进行管理的，当需要监视的文件描述符发生变化时，必须借助操作系统才能完成。

3. select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。请说明具体的差异，并解释为何存在这种差异。

   > 答：select方式：调用select函数进行等待事件的发生，并将所有监视对象文件描述符进行遍历；epoll方式：调用epoll_wait函数进行等待事件的发生，并将发生事件的监视对象文件描述符统一存储到epoll_event结构体数组中。因为epoll有专门对发生事件的监视对象描述符进行存储的epoll_event结构体。而select实现中并没有将发生事件的监视对象描述符分离出来保存，select中用fd_set结构体注册需要监视的文件描述符，也用fd_set结构体保存发生变化的文件描述符，而epoll通过epoll_create和epoll_event分别实现上述功能。

4. 虽然epoll时select的改进方案，但select也有自己的优点。在何种情况下使用select方式更合理？

   > 答：①服务器端的接入者少；②代码具有兼容性。

5. epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2种方式通知事件的时间点差异。

   > 答：条件触发和边缘触发的区别在于处理事件的时间点。条件触发：每当输入缓冲中有数据时就一直通知该事件；边缘触发：当输入缓冲中存在数据时只注册一次事件，即使没读取完也不会再对该事件进行通知。

6. 采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点。

   > 答：优点：分离接受数据和处理数据的时间点，给服务端的实现带来很大灵活性。原因：边缘触发中输入缓冲收到数据时仅注册1次该事件。根据这个特性更利于实现分离数据的接收和处理时间点，对数据的接收所注册的事件更少。

7. 实现聊天服务器端，使其可以在连接到服务器端的所有客户但之间交换消息。按照条件触发方式和边缘触发方式分别实现epoll服务器端（聊天服务器端的实现中，这2种方式不会产生太大差异）。当然，为了正常运行服务器端，需要聊天客户端，我们直接使用第18章的chat_clnt.c（编译方法请参考第18章）。虽然尚未学习第18章，但使用其中一些示例并非难事。

   > 答：暂略。

------



# 第十八章 多线程服务器端的实现

------

## 18.1 理解线程的概念

### 18.1.1 引入线程的背景

第10章介绍了多进程服务器端的实现方法。多进程模型与select或epoll相比的确有自身的优点，但同时也有问题。如前所述，创建进程（复制）的工作本身会给操作系统带来相当沉重的负担。而且每个进程具有独立的内存空间，所以进程间通信的实现难度也会随之提高（参考第11章）。换言之，多进程模型的缺点可概括如下：

- 创建进程的过程会带来一定的开销。
- 为了完成进程间数据交换，需要特殊的IPC技术。

但相比于下面的缺点，上述2个缺点不算什么。

> “每秒少则数十次、多则数千次的「上下文切换」(Context Switching)是创建进程时最大的开销。”

只有1个CPU（准确地说是CPU的运算设备CORE）的系统中不是也可以同时运行多个进程吗？这是因为系统将CPU事件分成多个微小的块后分配给了多个进程。为了分时使用CPU，需要「上下文切换」过程。下面了解一下「上下文切换」的概念。运行程序前需要将相应进程信息读入内存，如果运行进程A后需要紧接着运行进程B，就应该将进程A相关信息移除内存，并读入进程B相关信息。这就是上下文切换。但此时进程A的数据将被移出到硬盘，所以上下文切换需要很长时间。即使通过优化加快速度，也会存在一定的局限。

为了保持多进程的优点，同时在一定程度上克服其缺点，人们引入了线程（Thread）。这是为了将进程的各种劣势降至最低限度（不是直接消除）而设计的一种“轻量级进程”。线程相比于进程具有如下优点。

- 线程的创建和上下文切换比进程的创建和上下文切换更快。
- 线程间交换数据时无需特殊技术。

各位会逐渐体会到这些优点，可以通过接下来的说明和线程相关代码进行准确理解。



### 18.1.2 线程和进程的差异

线程是为了解决如下困惑登场的：

> “喂！为了得到多条代码执行流而复制整个内存区域的负担太重了！”

每个进程的内存空间都由保存全局变量的“数据区”、向malloc等函数的动态分配提供空间的堆（Heap）、函数运行时使用的栈（Stack）构成。每个进程都拥有这种独立空间，多个进程的内存结构如下图所示。

<img src="image\18.1.2.png" style="zoom:55%;margin:0px;" />

但如果以获得多个代码执行流为主要目的，则不应该像上图那样分离内存结构，而只需分离栈区域。通过这种方式可以获得如下优势。

- 上下文切换时不需要切换数据区和堆。
- 可以利用数据区和堆交换数据。

实际上这就是线程。线程为了保持多条代码执行流而隔开了栈区域，因此具有下图所示的内存结构：

<img src="image\18.1.2_2.png" style="zoom:68%;margin:0px;" />

如上图所示，多个线程将共享数据区和堆。为了保持这种结构，线程将在进程内创建并运行。也就是说，进程和线程可以定义为如下形式。

- 进程：在操作系统构成单独执行流的单位。
- 线程：在进程构成单独执行流的单位。

如果说进程的操作系统内部生成多个执行流，那么线程就在同一个进程内部创建多条执行流。因此，操作系统、进程、线程之间的关系可以通过下图表示：

<img src="image\18.1.2_3.png" style="zoom:40%;margin:0px;" />

以上就是线程的理论说明。没有实际编程就很难理解好线程，希望各位通过学习线程相关代码理解全部内容。



## 18.2 线程创建及运行

POSIX时Portable Operating System Interface for Computer Environment （适用于计算机环境可移植操作系统接口）的简写，是为了提高UNIX系列操作系统间的移植性而指定的API规范。下面要介绍的线程创建方法也是以POSIX标准为依据的。因此，它不仅适用于Linux，也适用于大部分UNIX系列的操作系统。

### 18.2.1 线程的创建和执行流程

线程具有单独的执行流，因此需要单独定义线程的main函数，还需要请求操作系统在单独的执行流中执行该函数，完成该功能的函数如下：

```c
#include<pthread.h>
int pthread_create(
	pthread_t* restrict thread,
    const pthread_attr_t* restrict attr,
	void* (*start_routine)(void*),
    void* restrict arg
)
```

> 成功时返回0，失败时返回其他值。
>
> 参数1：thread，保存新创建线程的ID的变量地址值。线程与进程相同，也需要用于区分不同的ID。
>
> 参数2：attr，用于传递线程属性的参数，传递NULL时，创建默认属性的线程。
>
> 参数3：start_routine，相当于线程main函数的、在单独执行流中执行的函数地址值（函数指针）。
>
> 参数4：arg，通过第三个参数传递调用函数时包含传递参数信息的变量地址值。

要想理解好上述函数的参数，需要熟练掌握restrict关键字和函数指针相关语法。下面通过简单示例了解该函数的功能。

- 代码示例：[thread1.c](SK18/thread1.c)

- 运行结果：

  ```
   gcc thread1.c -o tr1 -lptread
   ./tr1
  running thread
  running thread
  running thread
  running thread
  running thread
  end of main
  ```

从上述运行结果中可以看到，线程相关代码在编译时需要添加`-lpthread`选项，声明需要连接线程库，只有这样才能调用头文件pthread.h中声明的函数。上述程序的执行流程如下图所示：

<img src="image\18.2.1.png" style="zoom:50%;margin:0px;" />

上图中的虚线代表执行流程，向下的箭头指的是执行流，横向箭头是函数调用。这些都是简单的符号，可以结合示例理解。接下来将上述示例的sleep函数的调用语句改成如下形式：

```c
sleep(2);
```

各位运行后可以看到，此时不会像代码中写的那样输出5次“running thread”字符串。因为main函数返回后整个进程将被销毁，正因如此，我们在之前的示例中通过调用sleep函数向线程提供了充足的执行时间。

> “那线程相关程序中必须适当调用sleep函数！”

并非如此！通过调用sleep函数控制线程的执行相当于预测程序的执行流程，但实际上这是不可能完成的事情。而且稍有不慎，很可能干扰程序的正常执行流。例如，怎么可能在上述示例中准确预测thread_main函数的运行时间，并让main函数恰好等待这么长时间呢？因此，我们不用sleep函数，而是通过利用下面的函数控制线程的执行流。通过下列函数可以更有效地解决现讨论的问题，还可同时了解线程ID的用法。

```c
#include<pthread.h>
int pthread_join(pthread_t thread, void** status);
```

> 成功时返回0， 失败时返回其他值。
>
> 参数1：thread，该参数值ID的线程终止后才会从该函数返回。
>
> 参数2：status，保存线程的main函数返回值的指针变量地址值。

简言之，调用该函数的进程（或线程）将进入等待状态，直到第一个参数为ID的线程终止为止。而且可以得到线程的main函数返回值，所以该函数比较有用。下面通过示例了解该函数的功能。

- 代码示例：[thread2.c](SK18/thread2.c)

- 运行结果：

  ```
  gcc thread2.c -o tr2 -lpthread
  ./tr2
  running thread
  running thread
  running thread
  running thread
  running thread
  ```

  最后，为了让大家更好地理解该示例，给出其执行流程图，如下图所示。请注意观察程序暂停后从线程终止时（线程main函数返回时）重新执行的部分。

  <img src="image\18.2.1_3.png" style="zoom:70%;margin:0px;" />



### 18.2.2 可在临界区内调用的函数

之前的示例中只创建了1个线程，接下来的示例将开始创建多个线程。当然，无论创建多少线程，其创建方法没有区别。但关于线程的运行需要考虑“多个线程同时调用函数时（执行时）可能产生问题”。这类函数内部存在临界区（Critical Section），也就是说，多个线程同时执行这个部分代码时，可能引起问题。临界区中至少存在1条这类代码。

稍后将讨论哪些代码可能成为临界区，多个线程同时执行临界区代码时会产生哪些问题等内容。现阶段只需理解临界区的概念即可。根据临界区是否引起问题，函数可分为以下2类：

- 线程安全函数（Thread-safe function）
- 非线程安全函数（Thread-unsafe function）[理解：线程非安全函数]

线程安全函数被多个线程同时调用时也不会引发问题。反之，非线程安全函数被同时调用时会引发问题。但这并非关于有无临界区的讨论，线程安全的函数中同样可能存在临界区。只是在线程安全函数中，同时被多个线程调用时可通过一些措施避免问题。

幸运的是，大多数标准函数都是线程安全的函数。更幸运的是，我们不用自己区分线程安全的函数和非线程安全的函数。因为这些平台在定义非线程安全函数的同时，提供了具有相同功能的线程安全的函数。比如，第8章介绍过如下函数就不是线程安全的函数：

```c
struct hostent* gethostbyname(const char* hostname);
```

同时提供线程安全的同一功能函数：

```c
struct hostent* gethostbyname_r(
	const char* name, 
	struct hostent* result,
	char* buffer,
	int buflen,
	int* h_errnop
);
```

线程安全函数的名称后缀通常为_r（这与Windows平台不同）。既然如此，多个线程同时访问的代码块中应该调用gethostbyname_r，而不是gethostbyname？当然！但这种方法会给程序员带来沉重的负担。幸好可以通过如下方法自动将gethostbyname函数调用改为gethostbyname_r函数调用！

> “声明头文件前定义_REENTRANT宏。”

gethostbyname函数和gethostbyname_r函数的函数名和参数声明都不同，因此，这种宏声明方式拥有巨大的吸引力。另外， 无需为了上述宏定义特意添加#define语句，可以在编译时通过添加 `-D_REENTRANT`选项定义宏。

```
gcc -D_REENTRANT mythread.c -o mthread -lphread
```

下面编译线程相关代码时默认添加`-D_REENTRANT`选项。



### 18.2.3 工作（Worker）线程模型

之前示例的目的主要是介绍线程概念和创建线程的方法，因此从未涉及1个示例中创建多个线程的情况。下面给出此类示例。

将要介绍的示例：将计算1~10的和，但并不是在main函数中进行累加运算，而是创建2个线程，其中一个线程计算1到5的和，另一个线程计算6到10的和，main函数只负责输出运算结果。这种方式的编程模型称为「工作线程模型」(Worker thread)。计算1到5之和的线程与计算6到10之和的线程将成为main线程管理的工作（Worker）。最后，给出示例代码前先给出程序执行流程图，如下图所示：

<img src="image\18.2.3.png" style="zoom:80%;margin:0px;" />

- 示例代码参见：[thread3.c](SK18/thread3.c)

  > 需要注意：“2个线程直接访问全局变量sum。”
  >
  > 从代码的角度看似乎理所应当，但之所以可行完全是因为2个线程共享 保存全局变量的数据区。

- 运行结果：

  ```
  gcc thread3.c -D_REENTRANT -o tr3 -lpthread
  ./tr3
  result: 55
  ```

  运行结果时55，虽然正确，但示例本身存在问题。此处存在临界区相关问题，因此再介绍另一示例。该示例与上述示例相似，只是增加了发生临界区相关错误的可能性，即使在高配置系统环境下也容易验证产生的错误。

- 另一示例代码参见：[thread4.c](SK18/thread4.c)

- 运行结果：

  ```
  gcc thread4.c -D_REENTRANT -o tr4 -lpthread
  ./tr4
  sizeof long long: 8
  result: -3442772 
  
  ./tr4
  sizeof long long: 8
  result: 24388268 
  
  ./tr4
  sizeof long long: 8
  result: -4009950 
  ```

  运行结果并不是0！而且每次运行的结果均不同。虽然其原因尚不得而知，但可以肯定的是，这对于线程的应用是个大问题。



## 18.3 线程存在的问题和临界区

我们还不知道示例thread4.c中产生问题的原因，下面分析该问题并给出解决方案。

### 18.3.1 多个线程访问同一变量是问题

示例thread4.c的问题如下：

> “两个线程正在同时访问全局变量num。”

此处的“访问”是指值的更改。产生问题的原因可能还有很多，因此需要准确理解。虽然示例中访问的对象是全部变量，但这并非全局变量引发的问题。任何内存空间只要被同时访问都可能发生问题。

> “不是说线程会分时使用CPU吗？那应该不会出现同时访问变量的情况啊。”

当然，此处的“同时访问”与各位所想的有一定区别。下面通过示例解释“同时访问”的含义，并说明为何会引起问题。假设2个线程要执行将变量值逐次加1的工作，如下图所示：

<img src="image\18.3.1.png" style="zoom:55%;margin:0px;" />

上图描述的是2个线程准备将变量num的值加1的情况。在此状态下，线程1将变量num的值增加到100后，线程2再访问num时，变量num中间按照我们预先保存101。下图18-9时线程1将变量num完成增加后的情形。

<img src="image\18.3.1_2.png" style="zoom:40%;margin:0px;" />

上图中需要注意值得增加方式，值的增加需要CPU运算完成，变量num中的值不会自动增加。线程1首先读该变量的值并将其传递到CPU，获得加1之后的结果100，最后再把结果写回变量num，这样num中就保存100。接下来给出线程2的执行过程，如下图18-10所示。

<img src="image\18.3.1_3.png" style="zoom:50%;margin:0px;" />

变量num中将保存101，但这是理想的情况。线程1完全增加num值之前，线程2完全有可能通过切换得到CPU资源。

下面从头再来。下图18-11描绘的是线程1读取变量num的值并完成加1运算时的情况，只是加1后的结果尚未写入变量num。

<img src="image\18.3.1_4.png" style="zoom:40%;margin:0px;" />

接下来就要将100保存到变量num中，但执行该操作前，执行流程跳转到了线程2。幸运的是（是否真正幸运稍后再论），线程2完成了加1运算，并将加1之后的结果写入变量num，如下图18-12所示。

<img src="image\18.3.1_5.png" style="zoom:45%;margin:0px;" />

从上图可以看到，变量num的值尚未被线程1加到100，因此线程2读到的变量num的值为99，结果是线程2将num值改成100。还剩下线程1加运算后的值写入变量num的操作。接下来给出该过程，如下图18-13所示。

<img src="image\18.3.1_6.png" style="zoom:35%;margin:0px;" />

很可惜，此时线程1将自己的运算结果100再次写入变量num，结果变量num变成100。虽然线程1和线程2各做了1次加1运算，却得到了意想不到的结果。因此，线程访问变量num时应该阻止其他线程访问，直到线程1完成运算。这就是同步（Synchronization）。相信各位也意识到了多线程编程中「同步」的必要性，且能够理解thread4.c的运行结果。



### 18.3.2 临界区位置

划分临界区并不难。既然临界区定义为如下这种形式，那就在示例thread4.c中寻找。

> “函数内同时运行多个线程时引起问题的多条语句构成的代码块。”

全局变量num是否应该视为临界区？不是！因为它不是引起问题的语句。该变量并非同时运行的语句，只是代表内存区域的声明而已。临界区通常位于由线程运行的函数内部。下面观察示例thread4.c中的2个main函数：

```c
void* thread_inc(void* arg)
{
	int i;
	for(i = 0; i < 50000000; i++)
		num += 1;	//临界区
	return NULL;
}
void* thread_des(void* arg)
{
	int i;
	for(i = 0; i < 50000000; i++)
		num -= 1;	//临界区
	return NULL;
}
```

由代码注释可知，临界区并非num本身，而是访问num的2条语句。这2条语句可能由多个线程同时运行，也是引起问题的直接原因。产生的问题可以整理为如下3中情况。

- 2个线程同时执行thread_inc函数。
- 2个线程同时执行tread_des函数。
- 2个线程分别执行thread_inc函数和thread_des函数。

需要关注最后一点，它意味着如下情况下也会引发问题：

> “线程1执行thread_inc函数的`num+=1`语句的同时，线程2执行thread_des函数的num-=1语句。”

也就是说，2条不同语句由不同线程同时执行时，也有可能构成临界区。前提是2条语句访问同一内存空间。



## 18.4 线程同步

前面探讨了线程中存在的问题，接下来就要讨论解决方法，即「线程同步」。

### 18.4.1 同步的两面性

线程同步用于解决线程访问顺序引发的问题。需要同步的情况可以从如下两方面考虑。

- 同时访问同一内存空间时发生的情况。
- 需要指定访问内存空间的线程执行顺序的情况。

之前已解释过前一种情况，因此重点讨论第二种情况。这是“控制（Control）线程执行顺序”的相关内容。假设有A、B两个线程，线程A负责向指定内存空间写入（保存）数据，线程B负责取走该数据。这种情况下，线程A首先应该访问约定的内存空间并保存数据。万一线程B先访问取走数据，将导致错误结果。像这种需要控制执行顺序的情况也需要使用同步技术。

稍后将介绍「互斥量（Mutex）」和「信号量（Semaphore）」这两种同步技术。二者概念上十分接近，只要理解了互斥量就很容易掌握信号量。而且大部分同步技术的原理都大同小异，因此，只要掌握了本章介绍的同步技术，就很容易掌握并运用Windows平台下的同步技术。



### 18.4.2 互斥量

互斥量是“Mutual Exclusion”的简写，表示不允许多个线程同时访问，互斥量主要用于解决线程同步访问的问题。为了理解好互斥量，请观察如下对话过程。

<img src="image\18.4.2.png" style="zoom:40%;margin:0px;" />

相信各位也猜到了上述对话发生的场景。现实世界中的临界区就是洗手间。洗手间无法同时容纳多人（比作线程），因此可以将临界区比喻为洗手间。而且这里发生的所有事情几乎可以全部套用到临界区同步过程。洗手间使用规则如下。

- 为了保护个人隐私，进洗手间时锁上门，出来时再打开。
- 如果有人使用洗手间，其他人需要在外面等待。
- 等待的人数可能很多，这些人需要排队进入洗手间。

这就是洗手间的使用规则。同样，线程中为了保护临界区也需要套用上述规则。洗手间中存在，但之前的线程示例中缺少的是什么呢？就是锁机制。线程同步中同样需要锁，就像洗手间示例中使用的那样。互斥量就是一把优秀的锁，接下来介绍互斥量的创建及销毁函数。

```C
#include<pthread.h>

int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr);

int pthread_mutex_destroy(pthread_mutex_t* mutex);
```

> 成功时返回0，失败时返回其他值。
>
> 参数1：mutex，创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址值。
>
> 参数2：attr，传递即可创建的互斥量属性，没有特别需要指定的属性时传递NULL。

从上述函数声明中也可看出，为了创建相当于锁系统的互斥量，需要声明如下pthread_mutex_t型变量：

> pthread_mutex_t mutex;

该变量的地址将传递给pthread_mutex_init函数，用来保存操作系统创建的互斥量（锁系统）。调用pthread_mutex_destroy函数时同样需要该信息。如果不需要配置特殊的互斥量属性，则向第二个参数传递NULL时。

可以利用`PTHREAD_MUTEX_INITIALIZER`宏进行如下声明：

```C
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

但推荐各位尽可能使用pthread_mutex_init函数进行初始化，因为通过宏进行初始化时很难发现发生的错误。接下来介绍利用互斥量锁住或释放临界区使用的函数。

```c
#include<pthread.h>
int pthread_mutex_lock(pthread_mutex_t* mutex);
int pthread_mutex_unlock(pthread_mutex_t* mutex);
```

> 成功时返回0，失败时返回其他值。

函数名本身含有lock、unlock等词汇，很容易理解其含义。进入临界区调用的函数就是pthread_mutex_lock。调用该函数时，发现有其他线程已进入临界区，则pthread_mutex_lock函数不会返回，直到里面的线程调用pthread_mutex_unlock函数退出临界区为止。也就是说，其他线程让出临界区之前，当前线程将一直处于阻塞状态。接下来整理一下保护临界区的代码编写方法。创建好互斥量的前提下， 可以通过如下结构保护临界区：

```c
pthread_mutex_lock(&mutex);
//临界区的开始
//...
//临界区的结束
pthread_mutex_unlock(&mutex);
```

简言之，就是利用lock和unlock函数围住临界区的两端。此时互斥量相当于一把锁，阻止多个线程同时访问。还有一点需要注意，线程退出临界区时，如果忘了调用`pthread_mutex_unlock函数`，那么其他为了将纳入临界区而调用`pthread_mutex_lock函数`的线程就无法摆脱阻塞状态。这种情况称为「死锁（Dead-lock）」，需要格外注意。

接下来利用互斥量解决示例thread4.c中遇到的问题。

- 代码参见：[mutex.c](SK18/mutex.c)

- 运行结果：

  ```
  gcc mutex.c -D_REENTRANT -o mutex -lpthread
  ./mutex
  result: 0 
  ```

从运行结果可以看出，已解决了示例thread4.c中的问题。但确认运行结果需要等待较长时间。因为互斥量lock、unlock函数的调用过程要比想象中花费更长时间。首先分析一下thread_inc函数的同步过程。

```c
void* thread_inc(void* arg)
{
	int i;
	pthread_mutex_lock(&mutex);
	for(i = 0; i < 50000000; i++)
		num += 1;
	pthread_mutex_unlock(&mutex);
	return NULL;
}
```

以上临界区划分范围较大，但这是考虑如下优点所做的决定：

> “最大限度减少互斥量lock、unlock函数的调用次数。”

上述示例中，thread_des函数比thread_inc函数多调用49,999,999次互斥量lock、unlock函数，表现出人可以感知的速度差异。如果不太关注线程的等待时间，可以适当扩展临界区。但变量num的值增加到50,000,000前不允许其他线程访问，这反而成了缺点。其实这里没有正确答案，需要根据不同程序酌情考虑究竟扩大还是缩小临界区。此处没有公式可言，各位需要培养自己的判断能力。



### 18.4.3 信号量

下面介绍信号量。信号量与互斥量极为相似，在互斥量的基础上很容易理解信号量。此处只涉及利用“二进制信号量”（只用0和1）完成“控制线程顺序”为中心的同步方法。下面给出信号量创建及销毁方法。

```c
#include<semaphore.h>
int sem_init(sem_t* sem, int pshared, unsigned int value);
int sem_destroy(sem_t* sem);
```

> 成功时返回0，失败时返回其他值。
>
> 参数1：sem，创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值。
>
> 参数2：pshared，传递其他值时，创建可由多个进程共享的信号量；传递0时，创建只允许1个进程内部使用的信号量。我们需要完成统一进程内的线程同步，故传递0。
>
> 参数3：value，指定新创建的信号量初始值。

上述函数的pshared参数超出了我们关注的范围，故默认向其传递0。稍后讲解通过value参数初始化的信号量究竟是多少。接下来介绍信号量中相当于互斥量lock、unlock的函数。

```c
#include<semaphore.h>
int sem_post(sem_t* sem);
int sem_wait(sem_t* sem);
```

> 成功时返回0，失败时返回其他值。
>
> 参数：sem，传递保存信号量读取值的变量地址值，传递给sem_post时信号量增1，传递给sem_wait时信号量减1。

调用sem_init函数时，操作系统将创建信号量对象，此对象中记录着“信号量值”（Semaphore Value）整数。该值在调用sem_post函数时增1，调用sem_wait函数时减1。但信号量的值不能小于0，因此，在信号量为0的情况下调用sem_wait函数时，调用函数的线程将进入阻塞状态（因为函数未返回）。当然，此时如果有其他线程调用sem_post函数，信号量的值将变为1，而原本阻塞的线程可以将信号量重新减为0并跳出阻塞状态。实际上就是通过这种特性完成临界区的同步操作，可以通过如下形式同步临界区（假设信号量的初始值为1）。

```c
sem_wait(&sem);	//信号量为0...
//临界区的开始
//..........
//临界区的结束
sem_post(&sem);	//信号量变为1...
```

上述代码结构中，调用sem_wait函数进入临界区的线程在调用sem_post函数前不允许其他线程进入临界区。信号量的值在0和1之间跳转，因此，具有这种特性的机制称为“二进制信号量”。接下来给出信号量相关示例。即使介绍的示例并非关于同时访问的同步，二是关于控制访问顺序的同步。该示例的场景如下：

> “线程A从用户输入得到值后存入全局变量num，此时线程B将取走该值并累加。该过程共进行5次，完成后输出总和并退出程序。”

为了按照上述要求构建程序，应按照线程A、线程B的顺序访问变量num，且需要线程同步。接下来给出示例，分析该实例可能需要花费一定时间。

- 示例代码参见：[semaphore.c](SK18/semaphore.c)

- 运行结果：

  ```
  gcc semaphore.c -D_REENTRANT -o sema -lpthread   
  ./sema
  Input num: 2
  Input num: 4
  Input num: 6
  Input num: 8
  Input num: 10
  Result: 30
  ```

  下面再次基础上编写服务器端。



## 18.5 线程的销毁和多线程并发服务器端的实现

我们之前只讨论了线程的创建和控制，而线程的销毁同样重要。下面先介绍线程的销毁，再实现多线程服务器端。

### 18.5.1 销毁线程的3种方法

Linux线程并不是在首次调用的线程main函数返回时自动销毁，所以用如下2种方法之一加以明确。否则有线程创建的内存空间将一直存在。

- 调用pthread_join函数。
- 调用pthread_detach函数。

之前调用过pthread_join函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。<u>但该函数的问题是</u>，在线程终止前，调用该函数的线程将进入阻塞状态。因此，通常通过如下函数调用引导线程销毁。

```c
#include<pthread.h>
int pthread_detach(pthread_t thread);
```

> 参数：thread，终止的同时需要销毁的线程ID。

调用上述函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。调用该函数后不能再针对相应线程调用pthread_join函数，这需要格外注意。



### 18.5.2 多线程并发服务器端的实现

下面是多个客户端之间可以交换信息的简单聊天程序。

- 服务器端代码参见：[chat_server.c](SK18/chat_server.c)

  > 上述示例中，需要掌握的不是聊天服务器的实现方式，而是临界区的构成形式。上述示例中的临界区具有如下特点：
  >
  > ​		“访问全局变量clnt_cnt和数组clnt_socks的代码将构成临界区！”

  添加或删除客户端时，变量clnt_cnt和数组clnt_socks同时发生变化。因此，在如下情形中均会导致数据不一致，从而引发严重错误。

  - 线程A从数组clnt_socks中删除套接字信息，同时线程B读取clnt_cnt变量。
  - 线程A读取变量clnt_cnt，同时线程B将套接字信息添加到clnt_socks数组。

  因此，如上述示例所示，访问变量clnt_cnt和数组clnt_socks的代码应组织在一起并构成临界区。（此处的访问就是值的更改）

  

  接下来介绍聊天客户端，客户端示例为了分离输入和输出过程而创建了线程。

- 客户端代码参见：[chat_client.c](SK18/chat_client.c)



- 运行结果：服务器端：

  ```
  gcc chat_server.c -D_REENTRANT -o chat_serv -lpthread
  ./chat_serv 5009
  Connected client IP: 127.0.0.1 
  Connected client IP: 127.0.0.1 
  ```

- 运行结果：

  客户端 one：

  ```
  gcc chat_client.c -D_REENTRANT -o chat_clnt -lpthread
  ./chat_clnt 127.0.0.1 5009 小溪
  有人吗？
  [小溪] 有人吗？
  [小明] 有谁在啊？
  我我！
  [小溪] 我我！
  ```

  客户端 two：

  ```
  ./chat_clnt 127.0.0.1 5009 小明
  有谁在啊？
  [小明] 有谁在啊？
  [小溪] 我我！
  ```



## 18.6 习题

1. 单CPU系统中如何同时执行多个进程？请解释该过程中发生的上下文切换。

   > 答：系统将 CPU 时间分成多个微小的块后分配给了多个进程。为了分时使用 CPU ，需要「上下文 切换」过程。运行程序前需要将相应进程信息读入内存，如果运行进程A后需要紧接着运行进程 B，就应该将进程A相关信息移出内存，并读入进程B的信息，处理完毕后再将A的信息重新载入。这就是上下文切换

2. 为何线程的上下文切换速度相对更快？线程间数据交换为何不需要类似IPC的特别技术？

   > 答：①因为线程共享进程的数据区和堆区域，进行上下文切换不需要切换数据区和堆区。②因为线程可以通过数据区和堆区进行数据交换。

3. 请从执行流角度说明进程和线程的区别。

   > 答：进程是操作系统中构成单独执行流的单位 ；线程是进程中的构成单独执行流的单位。

4. 下列关于临界区的说法错误的是？

   **a.临界区是多个线程同时访问时发生问题的区域。**

   b.线程安全的函数中不存在临界区，即便多个线程同时调用也不会发生问题。

   c.1个临界区只能由1块代码块，而非多个代码块构成。换言之，线程A执行的代码块A和线程B执行的代码块B之间绝对不会构成临界区。

   d.临界区由访问全局变量的代码构成。其他变量中不会发生问题。

   > 答：上述加粗字体为正确答案。

5. 下列关于线程同步的描述错误的是？

   a.线程同步就是限制访问临界区。

   **b.线程同步也就有控制线程执行顺序的含义。**

   **c.互斥量和信号量是典型的同步技术。**

   d.线程同步是代替进程IPC的技术。

   > 答：上述加粗字体为正确答案。

6. 请说明完全销毁Linux线程的2种方法。

   > 答：①pthread_join函数。以阻塞的方式等待线程的终止并引导销毁；②pthread_detach，以非阻塞的方式等待线程的终止并引导销毁。

------





# 第二十四章 制作HTTP服务器端

------

## 24.1 HTTP概要

本章编写HTTP（Hypertext Transfer Protocol，超文本传输协议）服务器端，即Web服务器端。

### 24.1.1 理解Web服务器端

Web服务器端定义：

> “基于HTTP协议，将网页对应文件传输给客户端的服务器端。”

HTTP是Hypertext Transfer Protocol的缩写，Hypertext（超文本）是可以根据客户端请求而跳转的结构化信息。可跳转的文本（Text）称为超文本。

HTTP是以超文本传输为目的而设计的应用程协议，这种协议同样属于基于TCP/IP实现的协议，因此，我们可以直接实现HTTP。从结果上看，实现该协议相当于实现Web服务器端。总之，Web服务器端是以HTTP协议为基础传输传输超文本的服务器端。

### 24.1.2 HTTP

下面详细讨论HTTP协议：

- ##### 无状态的Stateless协议

  为了在网络环境下同时向大量客户端提供服务，HTTP协议的请求及响应方式设计如图24-1所示。

  <img src="image\24.1.2.png" style="zoom:60%;margin:0px;" />

  从上图可以看到，服务器端响应客户端请求后立即断开连接。换言之，服务器端不会维持客户端状态。即使同一客户端再次发送请求，服务器端也无法辨认出是原先那个，而会以相同方式处理新请求。因此，HTTP又称「无状态的(Stateless)协议」。

  | Cookie & Session                                             |
  | ------------------------------------------------------------ |
  | 为了弥补HTTP无法保持连接的缺点，Web编程中通常会使用Cookie和Session技术。相信各位都接触过购物网站的购物车功能，即使关闭浏览器也不会丢失购物车内的信息（甚至不用登陆）。这种保持状态的功能都是通过Cookie和Session技术实现的。 |



- ##### 请求消息（Request Message）的结构

  下面介绍客户端向服务器端发送的请求消息的结构。Web服务器端需要解析并响应客户端请求，客户端和服务器端之间的数据请求方式标准如下图所示：

  <img src="image\24.1.2_2.png" style="zoom:60%;margin:0px;" />

  从上图可以看到，请求消息分为3个部分：

  - **请求行：**包含请求方式（请求目的）信息。典型的请求方式GET和POST，GET主要用于请求数据，POST主要用于传输数据。
  - **请求头：**包含发送请求的（将要接收响应信息的）浏览器信息、用户认证信息等关于HTTP消息的附加信息。
  - **消息体：**装有客户端向服务器端传输的数据，为了装入数据，需要以POST方式发送请求。

  请求行中`GET/index.html HTTP/1.1`具有如下含义：

  > “请求（GET）index.html文件，希望以1.1版本的HTTP协议进行通信。”

  另外，消息体和消息头之间以空行分开，因此不会发生边界问题。

  

- **响应消息（Response Message）的结构**

  下面介绍Web服务器端向客户端传递的响应消息的结构。从下图中可以看出，该响应消息由状态行、头信息、消息体等三部分组成。状态行中有关于请求的状态信息，这是与请求消息相比最为明显的区别。

  <img src="image\24.1.2_3.png" style="zoom:70%;margin:0px;" />

  从上图可以看到，第一个字符状态行中含有关于客户端请求的处理结果。例如，客户端请求index.html文件时，表示index.html文件是否存在、服务端是否发生问题而无法响应等不同情况的信息将写入状态行。上图中的`HTTP/1.1 200 OK`具有如下含义：

  > “我想用HTTP1.1版本进行响应，你的请求已正确处理（200 OK）。”

  表示“客户端请求的执行结果”的数字称为状态码，典型的有以下几种。

  - 200 OK：成功处理了请求！
  - 404 Not Found：请求的文件不存在！
  - 400 Bad Request： 请求方式错误，请检查！

  消息头中含有传输的数据类型和长度等信息。上图中的消息头含有如下信息：

  > “服务器端名为SimpleWebServer，传输的数据类型为text/html（html格式的文本数据）。数据长度不超过2048字节。”

  最后插入1个空行后，通过消息体发送客户端请求的文件数据。以上就是实现Web服务器端过程中必要的HTTP协议。要编写完整的Web服务器端还需要更多HTTP协议相关知识，而对于我们的目标而言，这些内容已经足够了。

  

## 24.2 实现简单的Web服务器端

### 24.2.1 实现基于Linux的多线程Web服务器端

- 代码示例：[webserv_linux.c](SK24/webserv_linux.c)

- 编译运行

  ```
  gcc webserv_linux.c -D_REENTRANT -o webserv -lpthread
  ./webserv 5009
  ```

- 在浏览器输入框中，输入 `localhost:5009/index.html`

  <img src="image\24.png" alt="1" style="zoom:60%;margin:0px;" />



## 24.3习题

> 以下答案仅代表个人观点，可能不是正确答案

1. 下列关于Web服务器端和Web浏览器的说法错误的是？

   a.Web浏览器并不是通过自身创建的套接字连接服务器端的客户端。

   b.Web服务器通过TCP套接字提供服务，因为它将保持较长的客户端连接并交换数据。

   **c.超文本与普通文本的最大区别是具有可跳转的特性。**

   **d.Web服务器端可视为向浏览器提供请求文件的文件传输服务器端。**

   e.除Web浏览器外，其他客户端都无法访问Web服务器端。

   > 答：上述加粗字体为正确答案。

2. 下列关于HTTP协议的描述错误的是？

   a.HTTP协议是无状态的Stateless协议，不仅可以通过TCP实现，还可通过UDP实现。

   **b.HTTP协议是无状态的Stateless协议，因为其在1此请求和响应过程完成后立即断开连接。因此，如果同一服务器端和客户端需要3次请求及响应，则意味着要经过3次套接字创建过程。**

   **c.服务器端向客户端传递的状态码中含有请求处理结果信息。**

   **d.HTTP协议是基于因特网的协议，因此，为了同时向大量客户端提供服务，HTTP被设计为Stateless协议。**

   > 答：上述加粗字体为正确答案。

   







